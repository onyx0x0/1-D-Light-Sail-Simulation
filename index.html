<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>1D Laser Sail Sim</title>
    <style>
        * {
            box-sizing: border-box;
        }

        html {
            width: 100%;
            max-width: 100%;
            overflow-x: hidden;
            height: 100%;
            overscroll-behavior: none;
        }

        body {
            margin: 0;
            padding: 0;
            width: 100%;
            max-width: 100%;
            background: #050505;
            color: #eee;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            display: flex;
            height: 100%;
            overscroll-behavior: none;
        }
        body.is-mobile {
            position: fixed;
            inset: 0;
            width: 100%;
            height: calc(var(--vh, 1vh) * 100);
            overflow: hidden;
            touch-action: none;
            -webkit-text-size-adjust: 100%;
            text-size-adjust: 100%;
            box-sizing: border-box;
            padding-top: calc(4px + var(--safe-top));
            padding-bottom: calc(4px + var(--safe-bottom) + var(--browser-bottom));
        }

        :root {
            --mini-island-width: min(350px, calc(100vw - 32px));
            --control-box-width: 150px;
            --control-grid-gap: 10px;
            --control-row-height: 92px;
            --safe-top: env(safe-area-inset-top);
            --safe-bottom: env(safe-area-inset-bottom);
            --browser-bottom: 0px;
        }

        .page-loader {
            position: fixed;
            inset: 0;
            background: #050505;
            display: grid;
            place-items: center;
            z-index: 9999;
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
            transition: opacity 0.2s ease, visibility 0.2s ease;
        }

        .page-loader.is-visible {
            opacity: 1;
            visibility: visible;
            pointer-events: auto;
        }

        .page-loader-content {
            display: grid;
            justify-items: center;
            gap: 10px;
        }

        .page-loader-spinner {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: 3px solid rgba(255, 255, 255, 0.2);
            border-top-color: #ffffff;
            animation: loader-spin 0.9s linear infinite;
        }

        .page-loader-text {
            font-size: 12px;
            color: #cfcfcf;
            letter-spacing: 0.08em;
            text-transform: uppercase;
        }

        .panel {
            position: absolute;
            background: linear-gradient(180deg, rgba(12, 12, 14, 0.72), rgba(6, 6, 8, 0.68));
            padding: 20px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 10px 35px rgba(0, 0, 0, 0.55), inset 0 1px 0 rgba(255, 255, 255, 0.06);
            backdrop-filter: blur(14px) saturate(120%);
            z-index: 10;
        }

        #telemetry-island {
            top: 20px;
            left: 20px;
            width: 320px;
            display: flex;
            flex-direction: column;
        }

        #controls-island {
            left: 50%;
            bottom: calc(20px + var(--safe-bottom) + var(--browser-bottom));
            transform: translateX(-50%);
            width: max-content;
            max-width: calc(100vw - 40px);
        }

        #coupling-island {
            left: 20px;
            bottom: calc(20px + var(--safe-bottom) + var(--browser-bottom));
            width: max-content;
            max-width: calc(100vw - 40px);
            display: grid;
            place-items: center;
            padding: 14px;
        }

        #wavefront-island {
            position: fixed;
            right: 20px;
            bottom: calc(130px + var(--safe-bottom) + var(--browser-bottom)); /* Space for mission island + gap */
            width: var(--mini-island-width);
            z-index: 20;
        }

        #mission-escape-island {
            position: fixed;
            right: 20px;
            bottom: calc(20px + var(--safe-bottom) + var(--browser-bottom));
            width: var(--mini-island-width);
            z-index: 20;
        }

        #bottom-right-islands .panel {
            position: static;
            inset: auto;
        }

        .mini-island {
            padding: 10px 12px;
            border-radius: 10px;
            width: 100%;
        }

        .mission-island {
            display: grid;
            gap: 10px;
            width: 100%;
            max-width: 290px;
            padding: 12px;
            border-radius: 12px;
        }

        .mission-toggle-group {
            position: relative;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4px;
            padding: 4px;
            background: #0f0f0f;
            border: 1px solid #2a2a2a;
            border-radius: 10px;
            z-index: 1;
        }

        .mission-toggle-slider {
            position: absolute;
            top: 4px;
            bottom: 4px;
            left: 4px;
            width: calc(50% - 6px);
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 7px;
            transition: transform 0.35s cubic-bezier(0.4, 0, 0.2, 1), background 0.35s ease, border-color 0.35s ease;
            z-index: 0;
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.05);
            pointer-events: none;
        }

        .mission-toggle-group.is-xerionyx .mission-toggle-slider {
            background: #1a2a4a;
            border-color: #2a4a8a;
        }

        .mission-toggle-group.is-starshot .mission-toggle-slider {
            transform: translateX(calc(100% + 4px));
            background: #4a1a1a;
            border-color: #8a2a2a;
        }

        .mission-toggle-group.is-xerionyx .mission-toggle-button.is-active {
            color: #8ab4ff;
        }

        .mission-toggle-group.is-starshot .mission-toggle-button.is-active {
            color: #ff8a8a;
        }

        .mission-toggle-button {
            position: relative;
            z-index: 1;
            width: 100%;
            padding: 7px 8px;
            font-size: 10px;
            font-weight: 700;
            letter-spacing: 0.12em;
            text-transform: uppercase;
            background: transparent;
            color: #777;
            border: 1px solid transparent;
            border-radius: 7px;
            cursor: pointer;
            line-height: 1.1;
            transition: color 0.3s ease;
        }

        .mission-toggle-button:hover {
            color: #bbb;
            background: transparent;
        }

        .mission-toggle-button.is-active {
            color: #eee;
        }

.mission-toggle-button[data-tip] {
    position: relative;
}

.mission-toggle-button[data-tip]::after {
    content: attr(data-tip);
    position: absolute;
    left: 50%;
    bottom: calc(100% + 8px);
    transform: translateX(-50%);
    background: #0c0c0c;
    color: #e6e6e6;
    border: 1px solid #333;
    border-radius: 6px;
    padding: 6px 8px;
    font-size: 11px;
    line-height: 1.3;
    min-width: 180px;
    max-width: 220px;
    text-transform: none;
    letter-spacing: 0.02em;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.15s ease, transform 0.15s ease;
    transform-origin: center;
    z-index: 30;
}

.mission-toggle-button[data-tip]:hover::after {
    opacity: 1;
    transform: translateX(-50%) translateY(-2px);
}

#mission-starshot[data-tip]::after {
    transform: translateX(-60%);
}

#mission-starshot[data-tip]:hover::after {
    transform: translateX(-60%) translateY(-2px);
}


        .escape-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        .escape-label {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.12em;
            color: #b0b0b0;
            padding-left: 6px;
        }

        .escape-switch {
            position: relative;
            width: 46px;
            height: 24px;
            padding: 0;
            border-radius: 999px;
            border: 1px solid #333;
            background: #1a1a1a;
            display: inline-flex;
            align-items: center;
            justify-content: flex-start;
            cursor: pointer;
            transition: background 0.2s ease, border-color 0.2s ease;
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.04);
        }

        .escape-switch::after {
            content: "";
            position: absolute;
            top: 2px;
            left: 2px;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #d6d6d6;
            transition: transform 0.2s ease, background 0.2s ease;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.45);
        }

        .escape-switch.is-on {
            background: #1c3325;
            border-color: #2f4a36;
        }

        .escape-switch.is-on::after {
            transform: translateX(22px);
            background: #eafff0;
        }

        .escape-switch.is-off {
            background: #2a1515;
            border-color: #4a2323;
        }

        .escape-switch:hover {
            background: #202020;
        }

        .escape-switch.is-on:hover {
            background: #25402f;
        }

        .escape-switch.is-off:hover {
            background: #3d2020;
        }

        .telemetry {
            font-family: monospace;
            background: transparent;
            padding: 6px 0;
            margin-top: 0;
            border: none;
            font-size: 0.9em;
            line-height: 1.4em;
            flex: 1 1 auto;
            min-height: 0;
            overflow: hidden;
        }
        .telemetry.is-scroll {
            overflow-y: auto;
            padding-right: 6px;
            scrollbar-width: none;
        }
        .telemetry.is-scroll::-webkit-scrollbar {
            width: 0;
            height: 0;
        }
        .telemetry-header {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-top: 0;
            margin-bottom: 3px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            font-size: 11px;
            position: relative;
            width: 100%;
        }
        .header-actions {
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            gap: 6px;
        }
        .info-btn {
            width: 26px;
            height: 26px;
            padding: 0;
            border-radius: 6px;
            background: #1a1a1a;
            color: #e0e0e0;
            border: 1px solid #2a2a2a;
            cursor: pointer;
            font-weight: 700;
            font-size: 14px;
            line-height: 1;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        .info-btn:hover {
            background: #242424;
            border-color: #3a3a3a;
        }
        .wavefront-canvas-wrap {
            position: relative;
            width: 100%;
            height: 145px;
            background: #050505;
            border: 1px solid #333;
            border-radius: 6px;
            overflow: hidden;
            margin-bottom: 8px;
        }
        .wavefront-footer {
            display: grid;
            gap: 8px;
            width: 100%;
        }
        .wavefront-meta {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        .wavefront-meta-item {
            background: #0e0e0e;
            border: 1px solid #2a2a2a;
            border-radius: 8px;
            padding: 6px 8px;
            display: grid;
            gap: 3px;
        }
        .wavefront-meta-label {
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 0.14em;
            color: #777;
        }
        .wavefront-meta-value {
            font-size: 11px;
            color: #e6e6e6;
            font-family: Consolas, "Courier New", monospace;
            letter-spacing: 0.05em;
        }
        .wavefront-bar {
            background: #0b0b0b;
            border: 1px solid #2a2a2a;
            border-radius: 10px;
            padding: 8px;
            display: grid;
            gap: 6px;
        }
        .wavefront-bar-top {
            display: grid;
            grid-template-columns: auto 1fr;
            align-items: center;
            gap: 8px;
        }
        .wavefront-bar-title {
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 0.16em;
            color: #7f7f7f;
            white-space: nowrap;
        }
        .wavefront-bar-values {
            display: flex;
            justify-content: space-between;
            gap: 10px;
            width: 100%;
            font-size: 11px;
            color: #e6e6e6;
            font-family: Consolas, "Courier New", monospace;
            min-width: 0;
        }
        .wavefront-bar-value {
            min-width: 0;
            white-space: nowrap;
        }
        .wavefront-bar-track {
            position: relative;
            height: 10px;
            border-radius: 999px;
            background: linear-gradient(90deg, var(--wave-src-color, #4ea1ff), var(--wave-sail-color, #ff4e4e));
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.08);
            overflow: hidden;
        }
        .wavefront-bar-track::after {
            content: "";
            position: absolute;
            inset: 0;
            background: linear-gradient(90deg, rgba(255,255,255,0.08), rgba(255,255,255,0));
            pointer-events: none;
        }
        .wavefront-bar-marker {
            position: absolute;
            top: -3px;
            left: var(--wave-marker, 50%);
            width: 2px;
            height: 16px;
            background: #ffffff;
            transform: translateX(-50%);
            border-radius: 2px;
            box-shadow: 0 0 8px rgba(255, 255, 255, 0.6);
        }
        .wavefront-bar-labels {
            display: flex;
            justify-content: space-between;
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 0.16em;
            color: #6f6f6f;
        }
        .telemetry-row {
            position: relative;
            padding: 2px 0;
            cursor: help;
        }
        .telemetry-row::after {
            content: attr(data-tip);
            position: absolute;
            left: 0;
            top: 100%;
            margin-top: 6px;
            background: #0c0c0c;
            color: #e6e6e6;
            border: 1px solid #333;
            border-radius: 6px;
            padding: 6px 8px;
            font-size: 11px;
            line-height: 1.3;
            width: 260px;
            z-index: 20;
            opacity: 0;
            transform: translateY(-4px);
            transition: opacity 0.15s ease, transform 0.15s ease;
            pointer-events: none;
        }
        .telemetry-row:hover::after {
            opacity: 1;
            transform: translateY(0);
        }

        .control-group { margin-bottom: 15px; }
        .control-group label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            max-width: 220px;
            white-space: normal;
        }
        .control-group--center {
            display: flex;
            justify-content: center;
        }
        .toggle-row {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 12px;
            padding-top: 4px;
        }
        .toggle-subfield {
            width: 100%;
        }
        .toggle-subfield.is-hidden {
            display: none;
        }
        .toggle-label {
            font-size: 0.7em;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            text-align: center;
            width: 100%;
        }
        .toggle-switch {
            position: relative;
            width: 46px;
            height: 24px;
            border-radius: 999px;
            cursor: pointer;
            flex: 0 0 auto;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            align-self: center;
        }
        .toggle-switch input {
            position: absolute;
            opacity: 0;
            width: 0;
            height: 0;
            pointer-events: none;
        }
        .toggle-track {
            position: absolute;
            inset: 0;
            border-radius: 999px;
            border: 1px solid #333;
            background: #141414;
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.04);
            transition: background 0.2s ease, border-color 0.2s ease;
        }
        .toggle-knob {
            position: absolute;
            top: 3px;
            left: 2px;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #cfcfcf;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.45);
            transition: transform 0.2s ease, background 0.2s ease;
        }
        .toggle-switch input:checked + .toggle-track {
            background: #1c3325;
            border-color: #2f4a36;
        }
        .toggle-switch input:checked + .toggle-track + .toggle-knob {
            transform: translateX(24px);
            background: #eafff0;
        }
        label { display: block; font-size: 0.8em; color: #aaa; margin-bottom: 5px; }
        input[type="number"] { width: 100%; }

        .control-grid {
            display: grid;
            gap: var(--control-grid-gap);
            margin-bottom: 12px;
        }

        #controls-island .control-grid {
            grid-template-columns: repeat(2, var(--control-box-width));
            width: max-content;
            align-content: start;
            grid-auto-flow: row dense;
        }
        #controls-island .control-grid .control-box.is-hidden {
            display: none;
        }

        #controls-island .control-grid--single {
            grid-auto-rows: minmax(var(--control-row-height), auto);
            max-height: calc((var(--control-row-height) * 2) + var(--control-grid-gap));
            overflow-y: auto;
            padding-right: 6px;
        }

        #controls-island .control-grid--single::-webkit-scrollbar {
            width: 8px;
        }

        #controls-island .control-grid--single::-webkit-scrollbar-track {
            background: #0f0f0f;
            border-radius: 999px;
            margin: 6px 2px;
        }

        #controls-island .control-grid--single::-webkit-scrollbar-thumb {
            background: #2a2a2a;
            border-radius: 999px;
            border: 2px solid #0f0f0f;
        }

        #controls-island .control-grid--single::-webkit-scrollbar-thumb:hover {
            background: #3a3a3a;
        }

        .control-grid--stack {
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            align-items: flex-end;
            gap: 0;
            width: max-content;
        }

        #coupling-island .control-grid--stack {
            margin-bottom: 0;
        }

        #coupling-island .number-wrap {
            width: 120px;
        }

        .controls-layout {
            display: grid;
            grid-template-columns: repeat(3, max-content);
            gap: 16px;
            align-items: stretch;
            justify-content: center;
        }

        .controls-panel {
            background: rgba(12, 12, 12, 0.6);
            border: 1px solid #333;
            border-radius: 6px;
            padding: 12px;
            width: max-content;
            box-sizing: border-box;
            overflow: visible;
        }

        #controls-island .controls-panel {
            width: calc((var(--control-box-width) * 2) + var(--control-grid-gap) + 24px);
        }

        .panel-title {
            font-size: 11px;
            color: #888;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            margin-bottom: 10px;
            display: flex;
            justify-content: center;
            text-align: center;
            width: 100%;
        }

        .panel-title[data-tip] {
            position: relative;
            cursor: help;
        }

        .panel-title[data-tip]::after {
            content: attr(data-tip);
            position: absolute;
            left: 0;
            bottom: calc(100% + 6px);
            background: #0c0c0c;
            color: #e6e6e6;
            border: 1px solid #333;
            border-radius: 6px;
            padding: 6px 8px;
            font-size: 11px;
            line-height: 1.3;
            width: 240px;
            z-index: 20;
            opacity: 0;
            transform: translateY(-4px);
            transition: opacity 0.15s ease, transform 0.15s ease;
            pointer-events: none;
            text-transform: none;
            letter-spacing: 0.02em;
        }

        .panel-title[data-tip]:hover::after {
            opacity: 1;
            transform: translateY(-2px);
        }

        .coupling-header-row {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 10px;
            position: relative;
            width: 100%;
        }

        .coupling-header-row .panel-title {
            margin-bottom: 0;
            text-align: center;
        }

        .coupling-header-row .island-close-btn {
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
        }

        @media (max-width: 980px) {
            .controls-layout {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 820px) {
            body {
                flex-direction: column;
                align-items: stretch;
                overflow: auto;
                padding: 12px;
                gap: 12px;
            }

            #simCanvas {
                position: fixed;
                inset: 0;
                z-index: 0;
            }

            .panel {
                position: relative !important;
                inset: auto !important;
                transform: none !important;
            }

            #telemetry-island,
            #controls-island,
            #mission-escape-island {
                width: 100% !important;
                max-width: 100% !important;
                z-index: 5 !important;
            }

            #plot-island,
            #wavefront-island,
            #coupling-island,
            #extra-island {
                display: none;
            }

            .mobile-overlay {
                opacity: 0;
                visibility: hidden;
                pointer-events: none;
                transition: none;
            }
            
            #plot-island.is-open,
            #wavefront-island.is-open,
            #coupling-island.is-open,
            #extra-island.is-open {
                display: flex !important;
            }

            #mission-escape-island .escape-row {
                display: none;
            }

            #controls-island .controls-layout {
                grid-template-columns: 1fr;
                width: 100%;
            }

            #controls-island .controls-layout > .controls-panel:first-child,
            #controls-island .controls-layout > .controls-panel:last-child {
                display: none;
            }

            #controls-island .controls-layout > div {
                width: 100%;
            }

            #controls-island .controls-panel {
                width: 100%;
            }

            body.is-mobile input,
            body.is-mobile select,
            body.is-mobile textarea {
                font-size: 16px;
            }

            #controls-island .control-grid {
                grid-template-columns: 1fr;
            }

            #controls-island .control-box {
                width: 100%;
            }

            #controls-island .control-grid--single {
                max-height: none;
                overflow: visible;
            }

            #controls-island .main-actions-row {
                height: 42px;
            }

            #telemetry-island .telemetry-row {
                display: none;
            }

            #telemetry-island .telemetry-row.mobile-keep {
                display: block;
            }

            #telemetry-island hr {
                display: none;
            }

            #telemetry-island .telemetry {
                font-size: 0.85em;
            }

            #tutorial-btn {
                top: 12px;
                right: 12px;
                left: auto;
                transform: none;
            }
        }

        body.is-mobile {
            flex-direction: column;
            align-items: center;
            overflow: hidden;
            padding: calc(4px + var(--safe-top)) 4px calc(4px + var(--safe-bottom) + var(--browser-bottom));
            gap: 6px;
            min-height: 100vh;
        }

        body.is-mobile #simCanvas {
            position: fixed;
            inset: 0;
            z-index: 0;
        }

        body.is-mobile .panel {
            position: relative !important;
            inset: auto !important;
            transform: none !important;
        }

        body.is-mobile #telemetry-island,
        body.is-mobile #controls-island,
        body.is-mobile #mission-escape-island {
            width: min(360px, 100%) !important;
            max-width: 100% !important;
            z-index: 5 !important;
            margin-left: auto;
            margin-right: auto;
            padding: 8px;
        }

        body.is-mobile #controls-island {
            width: min(360px, 100%) !important;
        }

        body.is-mobile #telemetry-island { order: 1; margin-top: calc(50px + var(--safe-top)); }
        body.is-mobile #mission-escape-island { order: 2; margin-top: 0px; }
        body.is-mobile #controls-island { order: 3; margin-top: auto; margin-bottom: calc(20px + var(--safe-bottom) + var(--browser-bottom)); }

        body.is-mobile #plot-island,
        body.is-mobile #wavefront-island,
        body.is-mobile #coupling-island,
        body.is-mobile #extra-island {
            display: flex;
        }

        /* Strictly hide mobile elements on PC */
        .mobile-island-nav,
        .mobile-only-header,
        .mobile-only-btn,
        .desktop-hide {
            display: none !important;
        }

        /* Show nav on mobile with grid layout */
        body.is-mobile .mobile-island-nav {
            display: grid !important;
            grid-template-columns: repeat(4, 1fr) !important;
            gap: 6px !important;
            margin-bottom: 12px !important;
            width: 100% !important;
        }

        body.is-mobile .mobile-only-header,
        body.is-mobile .mobile-only-btn {
            display: flex !important;
        }

        body.is-mobile .mobile-overlay {
            display: flex !important;
            flex-direction: column !important;
            position: fixed !important;
            top: 50% !important;
            left: 50% !important;
            transform: translate(-50%, -50%) scale(0.96) !important;
            width: 95vw !important;
            height: auto !important;
            max-height: 90vh !important;
            z-index: 10000 !important;
            overflow-y: auto !important;
            overflow-x: hidden !important;
            background: linear-gradient(180deg, rgba(12, 12, 14, 0.98), rgba(6, 6, 8, 0.96)) !important;
            backdrop-filter: blur(20px) saturate(140%) !important;
            border: 1px solid rgba(255, 255, 255, 0.2) !important;
            box-shadow: 0 20px 60px rgba(0,0,0,0.9) !important;
            padding: 16px !important;
            border-radius: 12px !important;
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
            transition: opacity 0.35s ease, transform 0.35s ease, visibility 0.35s ease;
        }

        /* Overlays only show when opened */
        body.is-mobile .mobile-overlay.is-open {
            opacity: 1;
            visibility: visible;
            pointer-events: auto;
            transform: translate(-50%, -50%) scale(1) !important;
        }

        body.is-mobile .mobile-overlay.is-closing {
            opacity: 0;
            visibility: visible;
            pointer-events: none;
            transform: translate(-50%, -50%) scale(0.96) !important;
        }

        /* Narrower width for Coupling to match its content */
        body.is-mobile #coupling-island.is-open,
        body.is-mobile #coupling-island.is-closing {
            width: 240px !important;
            height: auto !important;
            overflow: visible !important;
        }

        body.is-mobile #coupling-island.is-open .control-grid--stack,
        body.is-mobile #coupling-island.is-closing .control-grid--stack {
            display: flex !important;
            flex-direction: column !important;
            align-items: stretch !important;
            width: 100% !important;
            gap: 10px !important;
        }

        body.is-mobile #coupling-island.is-open #coupling-target-box,
        body.is-mobile #coupling-island.is-closing #coupling-target-box {
            margin-left: 0 !important;
            width: 100% !important;
        }

        body.is-mobile #coupling-island.is-open .control-dropdown,
        body.is-mobile #coupling-island.is-closing .control-dropdown {
            width: 100% !important;
        }

        /* Set overflow specifically for islands that need it */
        body.is-mobile #extra-island.is-open,
        body.is-mobile #extra-island.is-closing {
            overflow-y: auto !important;
            overflow-x: hidden !important;
            -webkit-overflow-scrolling: touch;
            touch-action: pan-y;
        }

        body.is-mobile #plot-island.is-open,
        body.is-mobile #plot-island.is-closing,
        body.is-mobile #wavefront-island.is-open,
        body.is-mobile #wavefront-island.is-closing {
            overflow: visible !important; /* Allow dropdowns to pop out */
        }

        body.is-mobile #plot-island.is-open,
        body.is-mobile #plot-island.is-closing {
            height: min(60vh, 460px) !important;
            min-height: 280px !important;
        }

        body.is-mobile #plot-island .plot-controls {
            grid-template-columns: minmax(0, 1fr) minmax(0, 1fr) auto;
            gap: 6px;
        }

        body.is-mobile #plot-island .plot-controls > div {
            min-width: 0;
        }

        body.is-mobile #plot-island .color-map-dropdown,
        body.is-mobile #plot-island .color-map-toggle,
        body.is-mobile #plot-island .color-map-options {
            min-width: 0;
            width: 100%;
        }

        body.is-mobile #plot-island .color-map-toggle {
            padding: 6px 8px;
        }

        body.is-mobile #plot-island .color-map-toggle > span:first-child {
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        body.is-mobile #plot-island .plot-download {
            white-space: nowrap;
            padding: 8px 10px;
            font-size: 12px;
            min-width: 0;
        }

        /* Let Extra Control shrink to fit content */
        body.is-mobile #extra-island.is-open,
        body.is-mobile #extra-island.is-closing {
            height: auto !important;
            max-height: 90vh !important;
        }

        #extra-island-content {
            display: grid !important;
            grid-template-columns: 1fr 1fr !important;
            gap: 10px !important;
            align-items: start !important;
            width: 100% !important;
            max-width: 100% !important;
            overflow: visible !important;
        }

        body.is-mobile #extra-island .controls-panel {
            width: 100% !important;
            padding: 10px 6px !important;
            display: flex !important;
            flex-direction: column !important;
            background: rgba(20, 20, 20, 0.4) !important;
        }

        body.is-mobile #extra-island .control-grid--single {
            display: flex !important;
            flex-direction: column !important;
            gap: 10px !important;
            width: 100% !important;
        }

        body.is-mobile #extra-island .control-box {
            width: 100% !important;
            margin: 0 !important;
        }

        body.is-mobile #extra-island .control-box label {
            font-size: 0.65em !important;
            text-align: left !important;
        }

        .mobile-overlay.is-open #plot-canvas {
            width: 100% !important;
            height: 100% !important;
            flex: 1 !important;
            background: rgba(0,0,0,0.2) !important;
            border-radius: 4px !important;
            margin-top: 10px !important;
            display: block !important;
            min-height: 180px !important;
        }

        .nav-btn {
            background: #1a1a1a;
            border: 1px solid #333;
            color: #ccc;
            padding: 8px 2px;
            border-radius: 6px;
            font-size: 9px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            cursor: pointer;
            transition: all 0.2s;
        }

        .nav-btn:hover {
            background: #252525;
            border-color: #444;
            color: #fff;
        }

        body.is-mobile .mobile-only-header {
            display: flex !important;
        }

        body.is-mobile .island-close-btn {
            display: flex !important;
        }

        body.is-mobile #mission-escape-island .escape-row {
            display: flex;
        }

        body.is-mobile #controls-island .controls-layout {
            grid-template-columns: 1fr;
            width: 100%;
        }

        body.is-mobile #controls-island .controls-layout > .controls-panel:first-child,
        body.is-mobile #controls-island .controls-layout > .controls-panel:last-child {
            display: none;
        }

        body.is-mobile #controls-island .controls-layout > div {
            width: 100%;
        }

        body.is-mobile #controls-island .controls-panel {
            width: 100%;
        }

        body.is-mobile #controls-island .controls-panel {
            padding: 8px 6px;
        }

        body.is-mobile #controls-island .controls-panel {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0px;
        }

        body.is-mobile #controls-island .controls-panel .control-grid--single {
            row-gap: 6px;
        }

        body.is-mobile #controls-island .controls-panel .control-box {
            padding: 6px;
        }

        body.is-mobile #controls-island .controls-panel .control-grid--single {
            display: flex !important;
            justify-content: center !important;
            align-items: stretch;
            gap: 8px;
            width: 100%;
        }

        body.is-mobile #controls-island .controls-panel .control-box {
            width: 150px;
            margin: 0;
        }

        body.is-mobile #controls-island .control-box label {
            text-align: center;
            width: 100%;
        }

        body.is-mobile #telemetry-island .telemetry {
            padding: 8px 8px 4px;
            font-size: 0.86em;
            line-height: 1.35em;
        }

        body.is-mobile .telemetry-header {
            margin-top: 6px;
            margin-bottom: 2px;
        }

        body.is-mobile .main-actions-row {
            height: 32px;
        }

        body.is-mobile .action-btn {
            letter-spacing: 0.06em;
            font-size: 10px;
        }

        body.is-mobile .control-box label {
            font-size: 0.7em;
        }

        body.is-mobile #controls-island .control-grid {
            grid-template-columns: 1fr;
        }

        body.is-mobile #controls-island .controls-panel .control-grid--single {
            grid-template-columns: repeat(2, minmax(0, 1fr));
        }

        body.is-mobile #controls-island .control-box {
            width: 100%;
        }

        body.is-mobile #controls-island .control-grid--single {
            max-height: none;
            overflow: visible;
        }

        body.is-mobile #controls-island .main-actions-row {
            height: 42px;
        }

        body.is-mobile #telemetry-island .telemetry-row {
            display: none;
        }

        body.is-mobile #telemetry-island .telemetry-row.mobile-keep {
            display: block;
        }

        body.is-mobile #telemetry-island hr {
            display: none;
        }

        body.is-mobile #tutorial-btn {
            top: 12px;
            left: 50%;
            right: auto;
            transform: translateX(-50%);
        }

        .control-box {
            background: #0b0b0b;
            border: 1px solid #333;
            border-radius: 6px;
            padding: 8px;
            justify-self: start;
            width: max-content;
            min-width: 0;
            overflow: visible;
        }

        #controls-island .control-box {
            width: var(--control-box-width);
            box-sizing: border-box;
        }

        #coupling-target-box {
            margin-left: 10px;
            min-width: 0;
            overflow: hidden;
            transform: translateX(0);
            transition: opacity 0.2s ease, transform 0.2s ease, width 0.25s ease, max-width 0.25s ease, max-height 0.25s ease, padding 0.25s ease, margin 0.25s ease, border-width 0.25s ease;
        }

        #coupling-target-box.is-hidden {
            margin-left: 0;
        }

        .control-box label:not(.toggle-switch) {
            font-size: 0.75em;
            margin-bottom: 6px;
            max-width: 160px;
            white-space: normal;
            text-align: center;
            width: 100%;
        }

        .control-box input[type="number"] {
            background: #111;
            color: #eee;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 6px;
            font-family: monospace;
            box-sizing: border-box;
            appearance: textfield;
            -moz-appearance: textfield;
        }

        .control-select {
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            color: #e0e0e0;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 13px;
            outline: none;
            transition: border-color 0.12s ease, box-shadow 0.12s ease, background 0.12s ease, color 0.12s ease;
            min-width: 140px;
        }

        .control-select:hover {
            border-color: #3a3a3a;
            background: #1f1f1f;
        }

        .control-select:focus {
            border-color: #4a4a4a;
            background: #1f1f1f;
            box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.35), 0 8px 18px rgba(0, 0, 0, 0.35);
        }

        .select-hidden {
            position: absolute;
            width: 1px;
            height: 1px;
            margin: -1px;
            border: 0;
            padding: 0;
            clip: rect(0 0 0 0);
            overflow: hidden;
            white-space: nowrap;
        }

        .color-map-dropdown {
            position: relative;
        }

        .color-map-toggle {
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            color: #e0e0e0;
            padding: 8px 12px;
            border-radius: 10px;
            font-size: 13px;
            min-width: 140px;
            display: inline-flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
            cursor: pointer;
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.05);
            transition: background 0.18s ease, border-color 0.18s ease, box-shadow 0.18s ease;
            white-space: nowrap;
        }

        .color-map-toggle:hover {
            background: #1f1f1f;
            border-color: #3a3a3a;
        }

        .color-map-toggle:focus {
            outline: none;
            border-color: #4a4a4a;
            box-shadow: 0 14px 26px rgba(0, 0, 0, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.08);
        }

        .color-map-toggle .chevron {
            display: inline-flex;
            width: 18px;
            height: 18px;
            align-items: center;
            justify-content: center;
            color: #888;
            transition: transform 0.18s ease, color 0.18s ease;
        }

        .color-map-dropdown.open .color-map-toggle .chevron {
            transform: rotate(180deg);
            color: #bbb;
        }

        .color-map-options {
            position: absolute;
            top: calc(100% + 6px);
            left: 0;
            min-width: 180px;
            background: #111111;
            border: 1px solid #2a2a2a;
            border-radius: 14px;
            box-shadow: 0 16px 32px rgba(0, 0, 0, 0.55), inset 0 1px 0 rgba(255, 255, 255, 0.05);
            padding: 6px;
            overflow: hidden;
            box-sizing: border-box;
            opacity: 0;
            visibility: hidden;
            transform: translateY(-6px) scale(0.98);
            transition: opacity 0.18s ease, transform 0.18s ease, visibility 0.18s ease;
            z-index: 100;
        }

        .color-map-options-scroll {
            max-height: 240px;
            overflow-y: auto;
            overscroll-behavior: contain;
            scrollbar-color: #3a3a3a #0f0f0f;
            scrollbar-width: thin;
        }

        .color-map-options-scroll::-webkit-scrollbar {
            width: 8px;
        }

        .color-map-options-scroll::-webkit-scrollbar-track {
            background: #0f0f0f;
            border-radius: 999px;
            margin: 6px 2px;
        }

        .color-map-options-scroll::-webkit-scrollbar-thumb {
            background: #2a2a2a;
            border-radius: 999px;
            border: 2px solid #0f0f0f;
        }

        .color-map-options-scroll::-webkit-scrollbar-thumb:hover {
            background: #3a3a3a;
        }

        .color-map-dropdown.open .color-map-options {
            opacity: 1;
            visibility: visible;
            transform: translateY(0) scale(1);
        }

        .color-map-dropdown.open-up .color-map-options {
            top: auto;
            bottom: calc(100% + 6px);
            transform: translateY(6px) scale(0.98);
        }

        .color-map-dropdown.open-up.open .color-map-options {
            top: auto;
            bottom: calc(100% + 6px);
        }

        .color-map-option {
            width: 100%;
            background: transparent;
            border: none;
            color: #e0e0e0;
            text-align: left;
            padding: 6px 10px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.16s ease, color 0.16s ease;
            margin: 2px 0;
        }

        .color-map-option:hover {
            background: #1c1c1c;
            color: #ffffff;
        }

        .color-map-option.active {
            background: #1f1f1f;
            border: 1px solid #3a3a3a;
        }

        .control-dropdown {
            width: 100%;
        }

        .control-dropdown .color-map-toggle {
            width: 100%;
        }

        .control-dropdown .color-map-options {
            width: 100%;
        }

        .plot-dropdown .color-map-options {
        }

        .plot-dropdown .color-map-options-scroll {
            max-height: 420px;
            padding-right: 6px;
            scrollbar-gutter: stable;
        }

        .is-hidden {
            opacity: 0;
            width: 0;
            max-width: 0;
            max-height: 0;
            min-width: 0;
            padding: 0;
            border-width: 0;
            margin: 0;
            transform: translateX(-8px);
            pointer-events: none;
            overflow: hidden;
        }

        .control-box input[type="number"]::-webkit-outer-spin-button,
        .control-box input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .number-wrap {
            display: grid;
            grid-template-columns: 1fr 28px;
            gap: 6px;
            align-items: stretch;
            width: 100%;
        }

        .stepper {
            display: grid;
            grid-template-rows: 1fr 1fr;
            gap: 4px;
        }

        .stepper-btn {
            background: #151515;
            border: 1px solid #333;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0;
            line-height: 0;
            padding: 0;
            cursor: pointer;
        }

        .stepper-btn::before {
            content: "";
            display: block;
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
        }

        .stepper-btn[data-dir="1"]::before {
            border-bottom: 9px solid #666;
        }

        .stepper-btn[data-dir="-1"]::before {
            border-top: 9px solid #666;
        }

        .stepper-btn:hover {
            border-color: #444;
        }

        .stepper-btn:hover::before {
            border-bottom-color: #aaa;
            border-top-color: #aaa;
        }

        .control-group input[type="checkbox"] {
            appearance: none;
            width: 16px;
            height: 16px;
            border: 1px solid #444;
            border-radius: 4px;
            background: #0f0f0f;
            display: inline-grid;
            place-content: center;
            margin: 0;
        }

        .control-group input[type="checkbox"]:disabled {
            opacity: 0.45;
            cursor: not-allowed;
        }

        .control-group input[type="checkbox"]::after {
            content: "";
            width: 8px;
            height: 4px;
            border: 2px solid #00ffcc;
            border-top: 0;
            border-right: 0;
            transform: rotate(-45deg);
            opacity: 0;
        }

        .control-group input[type="checkbox"]:checked {
            border-color: #00ffcc;
            box-shadow: 0 0 0 1px rgba(0, 255, 204, 0.2);
        }

        .control-group input[type="checkbox"]:checked::after {
            opacity: 1;
        }

        label[data-tip] {
            cursor: help;
        }

        #control-tooltip {
            position: fixed;
            max-width: min(320px, 90vw);
            background: #0c0c0c;
            color: #e6e6e6;
            border: 1px solid #333;
            border-radius: 6px;
            padding: 6px 8px;
            font-size: 11px;
            line-height: 1.3;
            z-index: 1000;
            opacity: 0;
            transform: translateY(-4px);
            transition: opacity 0.12s ease, transform 0.12s ease;
            pointer-events: none;
            visibility: hidden;
        }

        #control-tooltip.is-visible {
            opacity: 1;
            transform: translateY(0);
            visibility: visible;
        }
        
        button {
            width: 100%;
            padding: 10px;
            cursor: pointer;
            background: transparent;
            color: white;
            border: none;
            border-radius: 4px;
            font-weight: bold;
            font-family: inherit;
        }
        button:hover { background: transparent; }
        button.active { background: #aa3333; }

        .main-actions-row {
            display: flex;
            align-items: stretch;
            justify-content: center;
            gap: 12px;
            width: 100%;
            margin-top: 10px;
            height: 48px; /* Taller for better click target */
            padding: 2px;
        }

        .action-btn {
            height: 100%;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Segoe UI', sans-serif;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            border-radius: 8px;
            border: none;
            outline: none;
            position: relative;
            transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
            user-select: none;
            text-shadow: 0 1px 1px rgba(0,0,0,0.4);
            box-shadow: 0 4px 0 rgba(0,0,0,0.3), 0 5px 10px rgba(0,0,0,0.3);
            transform: translateY(0);
        }

        .action-btn:active {
            transform: translateY(4px);
            box-shadow: 0 0 0 rgba(0,0,0,0.3), 0 0 0 rgba(0,0,0,0.3);
        }

        /* Start Laser Button - The Hero */
        #toggle-btn {
            flex: 2;
            min-width: 120px;
            background: linear-gradient(to bottom, #2ecc71, #27ae60);
            color: #fff;
            font-size: 14px;
            border-bottom: 1px solid #1e8449;
            box-shadow: 0 4px 0 #1e8449, 0 8px 15px rgba(0,0,0,0.3);
            z-index: 2;
        }
        
        #toggle-btn:hover {
            background: linear-gradient(to bottom, #40d681, #2ecc71);
            filter: brightness(1.1);
            box-shadow: 0 4px 0 #1e8449, 0 8px 20px rgba(46, 204, 113, 0.4);
        }

        #toggle-btn:active {
            box-shadow: 0 0 0 #1e8449, inset 0 2px 5px rgba(0,0,0,0.2);
            transform: translateY(4px);
        }

        #toggle-btn.active {
            background: linear-gradient(to bottom, #e74c3c, #c0392b);
            border-bottom: 1px solid #922b21;
            box-shadow: 0 4px 0 #922b21, 0 8px 15px rgba(231, 76, 60, 0.3);
        }
        
        #toggle-btn.active:hover {
            background: linear-gradient(to bottom, #ff6b5b, #e74c3c);
            box-shadow: 0 4px 0 #922b21, 0 8px 20px rgba(231, 76, 60, 0.4);
        }
        
        #toggle-btn.active:active {
            box-shadow: 0 0 0 #922b21, inset 0 2px 5px rgba(0,0,0,0.2);
        }

        /* Secondary Buttons */
        .sm-btn {
            flex: 1;
            font-size: 11px;
            min-width: 60px;
            background: linear-gradient(to bottom, #34495e, #2c3e50);
            color: #bdc3c7;
            border-bottom: 1px solid #1a252f;
            box-shadow: 0 4px 0 #1a252f, 0 4px 8px rgba(0,0,0,0.3);
        }

        .sm-btn:hover {
            background: linear-gradient(to bottom, #415b76, #34495e);
            color: #ecf0f1;
        }

        .sm-btn:active {
            box-shadow: 0 0 0 #1a252f, inset 0 2px 4px rgba(0,0,0,0.2);
            transform: translateY(4px);
        }

        #pause-btn {
            position: relative;
            overflow: hidden;
        }

        #pause-btn::after {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(230, 126, 34, 0.2);
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        #pause-btn:hover::after {
            opacity: 1;
        }
        
        #pause-btn.is-paused {
            background: linear-gradient(to bottom, #d35400, #a04000);
            color: #fff;
            box-shadow: 0 4px 0 #6e2c00, 0 4px 12px rgba(211, 84, 0, 0.4);
            animation: pulse-pause 1.5s infinite alternate;
            border-bottom: 1px solid #6e2c00;
        }
        
        #pause-btn.is-paused:active {
            box-shadow: 0 0 0 #6e2c00, inset 0 2px 4px rgba(0,0,0,0.2);
        }

        #restart-btn:hover {
            color: #e74c3c;
        }

        @keyframes pulse-pause {
            from { filter: brightness(1); }
            to { filter: brightness(1.2); }
        }

        canvas { display: block; }
        
        .val { color: #fff; float: right; }

        #plot-island {
            position: absolute;
            right: 20px;
            top: 20px;
            width: 520px;
            height: 520px;
            max-height: calc(100vh - 420px);
            background: linear-gradient(180deg, rgba(12, 12, 14, 0.7), rgba(6, 6, 8, 0.65));
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 8px;
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            box-shadow: 0 10px 35px rgba(0, 0, 0, 0.55), inset 0 1px 0 rgba(255, 255, 255, 0.06);
            backdrop-filter: blur(14px) saturate(120%);
            z-index: 9;
        }

        .plot-title {
            font-size: 11px;
            color: #888;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            text-align: center;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

.plot-title[data-tip] {
    position: relative;
    cursor: help;
}

        .plot-title[data-tip]::after {
            content: attr(data-tip);
            position: absolute;
            left: 0;
            top: calc(100% + 6px);
            background: #0c0c0c;
            color: #e6e6e6;
            border: 1px solid #333;
            border-radius: 6px;
            padding: 6px 8px;    font-size: 11px;
    line-height: 1.3;
    width: 240px;
    z-index: 20;
    opacity: 0;
    transform: translateY(-4px);
    transition: opacity 0.15s ease, transform 0.15s ease;
    pointer-events: none;
}

.plot-title[data-tip]:hover::after {
    opacity: 1;
    transform: translateY(0);
}

        .plot-controls {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px;
            align-items: end;
        }

        .plot-controls label {
            display: block;
            font-size: 0.75em;
            color: #aaa;
            margin-bottom: 4px;
            text-align: center;
            width: 100%;
        }


        .plot-download {
            width: auto;
            justify-self: end;
            min-height: 35px;
            padding: 8px 12px;
            font-size: 13px;
            font-weight: 600;
            letter-spacing: 0.02em;
            background: #1a1a1a;
            color: #e0e0e0;
            border: 1px solid #2a2a2a;
            border-radius: 10px;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        .plot-download:hover {
            background: #242424;
        }

.plot-download[data-tip] {
    position: relative;
    cursor: help;
}

.plot-download[data-tip]::after {
    content: attr(data-tip);
    position: absolute;
    left: 50%;
    top: calc(100% + 6px);
    transform: translateX(-50%);
    background: #0c0c0c;
    color: #e6e6e6;
    border: 1px solid #333;
    border-radius: 6px;
    padding: 6px 8px;
    font-size: 11px;
    line-height: 1.3;
    width: 260px;
    z-index: 20;
    opacity: 0;
    transform: translateX(-69%) translateY(-4px);
    transition: opacity 0.15s ease, transform 0.15s ease;
    pointer-events: none;
}

.plot-download[data-tip]:hover::after {
    opacity: 1;
    transform: translateX(-69%) translateY(0);
}

        #plot-canvas {
            flex: 1;
            width: calc(100% - 4px);
            height: 100%;
            background: transparent;
            border: none;
            border-radius: 4px;
            align-self: flex-start;
        }

        #plot-tooltip {
            position: absolute;
            display: none;
            background: #0c0c0c;
            color: #e6e6e6;
            border: 1px solid #333;
            border-radius: 6px;
            padding: 6px 8px;
            font-size: 13px;
            line-height: 1.3;
            font-family: Consolas, "Courier New", monospace;
            pointer-events: none;
            z-index: 2;
            white-space: nowrap;
        }

        @keyframes loader-spin {
            to {
                transform: rotate(360deg);
            }
        }
        .main-control-title {
            text-align: center;
            color: #888;
            font-size: 11px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            margin-bottom: 12px;
            width: 100%;
            position: relative;
        }
        .main-control-title .info-btn {
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
        }

        /* Tutorial Styles */
        #tutorial-btn {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            background: rgba(12, 12, 14, 0.72);
            color: #eee;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            letter-spacing: 0.05em;
            backdrop-filter: blur(10px);
            transition: background 0.2s, border-color 0.2s;
            width: auto;
            text-transform: uppercase;
            font-weight: 600;
        }
        #tutorial-btn:hover {
            background: rgba(40, 40, 45, 0.9);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .tutorial-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.75);
            z-index: 9000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.6s ease, visibility 0.6s ease;
            backdrop-filter: blur(3px);
            pointer-events: auto; /* Blocks clicks to background */
        }
        
        .tutorial-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        /* The box that holds the text */
        .tutorial-box {
            position: fixed;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.95);
            width: 90%;
            max-width: 460px;
            
            /* Glassmorphism theme matching the site panels */
            background: linear-gradient(180deg, rgba(12, 12, 14, 0.85), rgba(6, 6, 8, 0.80));
            border: 1px solid rgba(255, 255, 255, 0.12);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.6), inset 0 1px 0 rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(16px) saturate(120%);
            
            border-radius: 12px;
            padding: 30px;
            z-index: 9002;
            opacity: 0;
            visibility: hidden;
            
            /* Smooth entry/exit */
            transition: opacity 0.4s ease, transform 0.4s cubic-bezier(0.2, 0.8, 0.2, 1), visibility 0.4s ease;
            
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .tutorial-box.active {
            opacity: 1;
            visibility: visible;
            transform: translate(-50%, -50%) scale(1);
        }

        .tutorial-text {
            font-size: 15px;
            line-height: 1.6;
            color: #e0e0e0;
            /* Fade text change */
            transition: opacity 0.2s ease;
        }
        
        .tutorial-text.fade-out {
            opacity: 0;
        }
        
        .tutorial-text strong {
            color: #ffffff;
            font-weight: 600;
        }

        .tutorial-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 10px;
        }
        
        .tutorial-next-btn {
            background: #7c3aed;
            color: white;
            border: none;
            padding: 10px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            width: auto;
            font-weight: 600;
            transition: background 0.2s;
            box-shadow: none;
        }
        .tutorial-next-btn:hover { background: #a855f7; }
        
        .tutorial-skip-btn, .tutorial-back-btn {
            background: transparent;
            color: #888;
            border: none;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 13px;
            width: auto;
            transition: color 0.2s;
        }
        .tutorial-skip-btn:hover, .tutorial-back-btn:hover { 
            color: #ffffff; 
            background: transparent;
        }

        .tutorial-learn-more-btn {
            background: rgba(255, 255, 255, 0.08);
            color: #cfcfcf;
            border: 1px solid rgba(255, 255, 255, 0.15);
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.2s;
            visibility: hidden; /* Only visible on specific steps */
            opacity: 0;
        }
        .tutorial-learn-more-btn.is-visible {
            visibility: visible;
            opacity: 1;
        }
        .tutorial-learn-more-btn:hover {
            background: rgba(255, 255, 255, 0.15);
            color: #fff;
            border-color: rgba(255, 255, 255, 0.3);
        }

        .tutorial-info-box {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.95);
            width: 90%;
            max-width: 620px; /* Slightly wider to accommodate inset scroll */
            background: linear-gradient(180deg, rgba(12, 12, 14, 0.96), rgba(6, 6, 8, 0.92));
            border: 1px solid rgba(255, 255, 255, 0.12);
            box-shadow: 0 30px 70px rgba(0, 0, 0, 0.8), inset 0 1px 0 rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(24px) saturate(140%);
            border-radius: 16px;
            padding: 0; /* Remove padding here */
            z-index: 11000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.4s cubic-bezier(0.2, 0.8, 0.2, 1);
            max-height: 85vh;
            overflow: hidden; /* Contain the scroll wrapper */
            box-sizing: border-box;
        }
        .tutorial-info-scroll {
            width: 100%;
            max-height: 85vh;
            overflow-y: auto;
            padding: 40px;
            box-sizing: border-box;
            scrollbar-width: thin;
            scrollbar-color: #3a3a3a transparent;
        }
        .tutorial-info-scroll::-webkit-scrollbar {
            width: 8px;
        }
        .tutorial-info-scroll::-webkit-scrollbar-track {
            background: transparent;
            margin: 20px 0;
        }
        .tutorial-info-scroll::-webkit-scrollbar-thumb {
            background: #2a2a2a;
            border-radius: 999px;
            border: 2px solid rgba(12, 12, 14, 0.96); /* Match background to appear inset */
        }
        .tutorial-info-scroll::-webkit-scrollbar-thumb:hover {
            background: #3a3a3a;
        }
        .tutorial-info-box.active {
            opacity: 1;
            visibility: visible;
            transform: translate(-50%, -50%) scale(1);
        }
        .tutorial-info-content {
            font-size: 15px;
            line-height: 1.7;
            color: #d0d0d0;
        }
        .tutorial-info-content h2 {
            color: #fff;
            margin-top: 0;
            margin-bottom: 20px;
            font-size: 22px;
            letter-spacing: 0.02em;
        }
        .tutorial-info-content p {
            margin-bottom: 16px;
        }
        .tutorial-info-content strong {
            color: #fff;
        }
        .tutorial-info-animation {
            width: 100%;
            height: 220px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            margin: 24px 0;
            overflow: hidden;
        }
        .tutorial-info-close {
            display: block;
            margin: 30px auto 0;
            background: #444;
            color: #fff;
            border: none;
            padding: 10px 30px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            width: auto;
            transition: background 0.2s;
        }
        .tutorial-info-close:hover { background: #555; }

        /* The active element "pops" out of the darkness by having a higher z-index */
        .tutorial-highlight {
            z-index: 9001 !important;
            /* No position change to avoid breaking layout */
            transition: z-index 0s linear 0s;
        }

        /* Mobile Expand Button Styles */
        .mobile-only-btn {
            display: none;
        }

        @media (max-width: 820px) {
            .mobile-only-btn {
                display: flex;
            }

            /* Override default mobile hiding to allow animation */
            #telemetry-island .telemetry-row {
                display: block !important;
                max-height: 0;
                opacity: 0;
                margin: 0;
                padding: 0;
                overflow: hidden;
                transition: max-height 0.4s cubic-bezier(0.25, 1, 0.5, 1), opacity 0.3s ease, padding 0.3s ease;
            }

            #telemetry-island .telemetry-row.mobile-keep {
                max-height: 50px; /* Arbitrary large enough height */
                opacity: 1;
                padding: 2px 0;
            }

            #telemetry-island hr {
                display: block !important;
                border: 0;
                border-top: 1px solid #333;
                margin: 0;
                opacity: 0;
                max-height: 0;
                overflow: hidden;
                transition: all 0.3s ease;
            }

            /* Expanded State */
            #telemetry-island.expanded .telemetry-row {
                max-height: 50px;
                opacity: 1;
                padding: 2px 0;
            }

            #telemetry-island.expanded hr {
                opacity: 1;
                margin: 4px 0;
                max-height: 1px;
            }
        }
    </style>
</head>
<body>

<button id="tutorial-btn" type="button">Tutorial</button>

<div id="page-loader" class="page-loader" aria-hidden="true">
    <div class="page-loader-content">
        <div class="page-loader-spinner" aria-hidden="true"></div>
        <div class="page-loader-text">Loading...</div>
    </div>
</div>

<div id="telemetry-island" class="panel">
    <div class="telemetry-header">
        <span class="control-tip" data-tip="Telemetry panel overview: real-time state, laser, aero, and thermal metrics.">Telemetry</span>
        <div class="header-actions">
            <button type="button" id="telemetry-expand-btn" class="info-btn mobile-only-btn" aria-label="Expand telemetry">+</button>
            <button type="button" id="telemetry-info-btn" class="info-btn" aria-label="Telemetry details">!</button>
        </div>
    </div>
    <div class="telemetry">
        <div class="telemetry-row mobile-keep" data-tip="Altitude above sea level.">Altitude: <span class="val" id="tel-h">0</span></div>
        <div class="telemetry-row" data-tip="Line-of-sight range from ground laser to sail.">LOS Range: <span class="val" id="tel-range">0</span></div>
        <div class="telemetry-row mobile-keep" data-tip="Vertical velocity relative to the ground.">Velocity: <span class="val" id="tel-v">0</span></div>
        <div class="telemetry-row mobile-keep" data-tip="Net acceleration from laser, drag, and gravity.">Accel: <span class="val" id="tel-a">0</span></div>
        <div class="telemetry-row mobile-keep" data-tip="Elapsed simulation time.">Sim Time: <span class="val" id="tel-real">00:00:00</span></div>
        <div class="telemetry-row" data-tip="Accumulated energy cost from emitted power.">Electric Cost: <span class="val" id="tel-cost">$0.00</span></div>
        <div class="telemetry-row mobile-keep" data-tip="Velocity as a fraction of the speed of light (v/c).">v/c: <span class="val" id="tel-vc">0</span></div>
        <div class="telemetry-row" data-tip="Observed laser wavelength at the sail, including Doppler shift.">_sail: <span class="val" id="tel-lambda">0</span></div>
        <hr style="border:0; border-top:1px solid #333">
        <div class="telemetry-row" data-tip="Laser power emitted at the source.">P_emit: <span class="val" id="tel-pemit">0</span></div>
        <div class="telemetry-row" data-tip="Power intercepted by the sail.">P_hit: <span class="val" id="tel-phit">0</span></div>
        <div class="telemetry-row" data-tip="Power absorbed by the sail material.">P_abs: <span class="val" id="tel-pabs">0</span></div>
        <div class="telemetry-row" data-tip="Average irradiance over the sail area.">I_avg: <span class="val" id="tel-irr">0</span></div>
        <div class="telemetry-row" data-tip="Peak irradiance at the beam center.">I_peak: <span class="val" id="tel-irr0">0</span></div>
        <div class="telemetry-row" data-tip="Beam spot radius at the sail (1/e^2).">Beam radius: <span class="val" id="tel-w">0</span></div>
        <div class="telemetry-row" data-tip="Angular diameter of the sail as seen from the ground laser.">Angular size: <span class="val" id="tel-ang">0</span></div>
        <div class="telemetry-row" data-tip="Half-angle pointing tolerance for keeping the beam centered.">Pointing tol: <span class="val" id="tel-ptol">0</span></div>
        <div class="telemetry-row" data-tip="Beam radius divided by sail radius.">Beam/sail ratio: <span class="val" id="tel-bratio">0</span></div>
        <div class="telemetry-row" data-tip="Fraction of beam power captured by the sail.">Capture f_hit: <span class="val" id="tel-fhit">0</span></div>
        <div class="telemetry-row" data-tip="Ablation thrust force from the laser.">F_laser: <span class="val" id="tel-fl">0</span></div>
        <div class="telemetry-row" data-tip="Aerodynamic drag force.">F_drag: <span class="val" id="tel-fd">0</span></div>
        <div class="telemetry-row" data-tip="Dynamic pressure q = 0.5 * rho * v^2.">Dyn pressure: <span class="val" id="tel-q">0</span></div>
        <div class="telemetry-row" data-tip="Mach number based on local speed of sound.">Mach: <span class="val" id="tel-mach">0</span></div>
        <div class="telemetry-row" data-tip="Reynolds number based on sail diameter.">Re: <span class="val" id="tel-re">0</span></div>
        <div class="telemetry-row" data-tip="Stagnation temperature from compressible flow estimate.">T_stag: <span class="val" id="tel-tstag">0</span></div>
        <div class="telemetry-row" data-tip="Aero heating flux from the model.">Heat flux: <span class="val" id="tel-qdot">0</span></div>
        <div class="telemetry-row" data-tip="Local air density from the atmosphere model.">Density: <span class="val" id="tel-rho">0</span></div>
        <div class="telemetry-row" data-tip="Sail temperature from the thermal model.">Temp: <span class="val" id="tel-temp">0</span></div>
        <div class="telemetry-row" data-tip="Effective exhaust velocity implied by coupling.">V_eff: <span class="val" id="tel-ve">0</span></div>
        <div class="telemetry-row" data-tip="Specific impulse implied by coupling.">Isp: <span class="val" id="tel-isp">0</span></div>
        <div class="telemetry-row" data-tip="Cumulative impulse from laser thrust.">Impulse: <span class="val" id="tel-imp">0</span></div>
        <div class="telemetry-row" data-tip="Cumulative energy arriving at the sail.">E_hit: <span class="val" id="tel-ehit">0</span></div>
        <div class="telemetry-row" data-tip="Cumulative energy absorbed by the sail.">E_abs: <span class="val" id="tel-eabs">0</span></div>
        <div class="telemetry-row" data-tip="Specific orbital energy (epsilon).">Escape : <span class="val" id="tel-eps">0</span></div>
        <div class="telemetry-row mobile-keep" data-tip="Simulation state or failure reason.">Status: <span class="val" id="tel-status">OK</span></div>
    </div>
    
</div>

<div id="controls-island" class="panel">
    <div class="mobile-island-nav">
        <button type="button" class="nav-btn" id="nav-plot">Plot</button>
        <button type="button" class="nav-btn" id="nav-wavefront">Wavefront</button>
        <button type="button" class="nav-btn" id="nav-coupling">Coupling</button>
        <button type="button" class="nav-btn" id="nav-extra">Extra Control</button>
    </div>
    <div class="controls-layout">
            <div class="controls-panel">
                <div class="panel-title" data-tip="Laser controls the beamer output and optics that shape the beam.">Laser</div>
            <div class="control-grid control-grid--single">
                <div class="control-box">
                    <label class="control-tip" data-tip="Laser output power at the source in megawatts.">Power (<span id="p-mode">emit</span>) (MW)</label>
                    <div class="number-wrap">
                        <input type="number" id="power-slider" min="0" max="300000" step="0.01" value="0.07" data-precision="2">
                        <div class="stepper">
                            <button type="button" class="stepper-btn" data-dir="1">^</button>
                            <button type="button" class="stepper-btn" data-dir="-1">v</button>
                        </div>
                    </div>
                </div>
                <div class="control-box">
                    <label class="control-tip" data-tip="Effective diameter of the transmitting optic (aperture) in meters.">Aperture Diameter (m)</label>
                    <div class="number-wrap">
                        <input type="number" id="aperture-slider" min="0.1" max="3000" step="0.1" value="4" data-precision="1">
                        <div class="stepper">
                            <button type="button" class="stepper-btn" data-dir="1">^</button>
                            <button type="button" class="stepper-btn" data-dir="-1">v</button>
                        </div>
                    </div>
                </div>
                <div class="control-box">
                    <label id="div-label" class="control-tip" data-tip="Beam half-angle divergence in milliradians (manual unless diffraction-locked).">Beam Divergence (mrad)</label>
                    <div class="number-wrap">
                        <input type="number" id="div-input" min="0" max="10" step="0.000001" value="0.01" data-precision="auto">
                        <div class="stepper">
                            <button type="button" class="stepper-btn" data-dir="1">^</button>
                            <button type="button" class="stepper-btn" data-dir="-1">v</button>
                        </div>
                    </div>
                    <div class="toggle-row">
                        <span class="toggle-label control-tip" data-tip="Use diffraction-limited beam model.">Diffraction Beam</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="diffraction-toggle">
                            <span class="toggle-track"></span>
                            <span class="toggle-knob"></span>
                        </label>
                    </div>
                </div>
                <div class="control-box">
                    <label class="control-tip" data-tip="Laser wavelength in nanometers. Affects diffraction-limited beam spread.">Wavelength (nm)</label>
                    <div class="number-wrap">
                        <input type="number" id="wavelength-input" min="200" max="2000" step="1" value="450" data-precision="0">
                        <div class="stepper">
                            <button type="button" class="stepper-btn" data-dir="1">^</button>
                            <button type="button" class="stepper-btn" data-dir="-1">v</button>
                        </div>
                    </div>
                </div>
                <div class="control-box">
                    <label class="control-tip" data-tip="Manual override for beam spot radius at the sail (1/e^2), in meters.">Beam radius at sail (m)</label>
                    <div class="number-wrap">
                        <input type="number" id="beam-radius-input" min="0" max="10000" step="0.01" value="0" data-precision="auto">
                        <div class="stepper">
                            <button type="button" class="stepper-btn" data-dir="1">^</button>
                            <button type="button" class="stepper-btn" data-dir="-1">v</button>
                        </div>
                    </div>
                </div>
                <div class="control-box">
                    <label class="control-tip" data-tip="Atmospheric transmission at zenith (0 to 1).">Atm Transmission (0-1)</label>
                    <input type="number" id="transmission-input" min="0" max="1" step="0.001" value="0.6" data-precision="3">
                </div>
                <div class="control-box">
                    <label class="control-tip" data-tip="Beam quality (Strehl-like). Lower values spread the spot.">Beam Quality (0.05-1)</label>
                    <input type="number" id="beam-quality-input" min="0.05" max="1" step="0.01" value="0.85" data-precision="2">
                </div>
                <div class="control-box">
                    <label class="control-tip" data-tip="Minimum spot radius floor to emulate turbulence/seeing.">Spot Floor (m)</label>
                    <input type="number" id="spot-floor-input" min="0" max="10" step="0.0001" value="0.0001" data-precision="auto">
                </div>
            </div>
        </div>
        <div style="display: flex; flex-direction: column; align-items: center; gap: 8px; height: 100%;">
            <div class="main-control-title" style="margin: 0; flex: 1; display: flex; align-items: center; justify-content: center;">
                <span class="control-tip" data-tip="Main control panel: start/stop, pause, reset, time speed, and altitude.">Main Control</span>
                <button type="button" id="main-control-info-btn" class="info-btn" aria-label="Main control details">!</button>
            </div>
            <div class="controls-panel">
                <div class="panel-title" data-tip="Simulation settings control time speed, start altitude, and power coupling behavior.">Simulation</div>
            <div class="control-grid control-grid--single">
                <div class="control-box">
                    <label class="control-tip" data-tip="Simulation time multiplier. Higher values run the sim faster.">Time Speed (x)</label>
                    <div class="number-wrap">
                        <input type="number" id="speed-slider" min="0.1" max="1000" step="0.1" value="1" data-precision="2">
                        <div class="stepper">
                            <button type="button" class="stepper-btn" data-dir="1">^</button>
                            <button type="button" class="stepper-btn" data-dir="-1">v</button>
                        </div>
                    </div>
                </div>
                <div class="control-box">
                    <label class="control-tip" data-tip="Initial altitude of the sail at the start of the simulation, in meters.">Start Altitude (m)</label>
                    <div class="number-wrap">
                        <input type="number" id="altitude-slider" min="0" max="100000000" step="1000" value="48000" data-precision="0">
                        <div class="stepper">
                            <button type="button" class="stepper-btn" data-dir="1">^</button>
                            <button type="button" class="stepper-btn" data-dir="-1">v</button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="main-actions-row">
                <button id="pause-btn" class="action-btn sm-btn" data-tip="Pause/Resume the simulation.">PAUSE</button>
                <button id="toggle-btn" class="action-btn">START LASER</button>
                <button id="restart-btn" class="action-btn sm-btn" data-tip="Reset position and velocity to defaults without changing parameters.">RESTART</button>
            </div>
        </div>
        </div>
        <div class="controls-panel">
            <div class="panel-title" id="sail-panel-title" data-tip="Ablative sail parameters: thrust coupling, reflectance, divergence, and mass for the atmospheric mission.">Ablative Sail</div>
            <div class="control-grid control-grid--single">
                <div class="control-box">
                    <label class="control-tip" data-tip="Physical diameter of the sail in meters.">Sail Diameter (m)</label>
                    <div class="number-wrap">
                        <input type="number" id="sail-diameter-input" min="0.01" max="10" step="0.01" value="2" data-precision="2">
                        <div class="stepper">
                            <button type="button" class="stepper-btn" data-dir="1">^</button>
                            <button type="button" class="stepper-btn" data-dir="-1">v</button>
                        </div>
                    </div>
                </div>
                <div class="control-box">
                    <label class="control-tip" data-tip="Total sailcraft mass in kilograms (sail + payload).">Total Mass (kg)</label>
                    <div class="number-wrap">
                        <input type="number" id="mass-input" min="0.0001" max="1" step="0.000001" value="0.001" data-precision="auto">
                        <div class="stepper">
                            <button type="button" class="stepper-btn" data-dir="1">^</button>
                            <button type="button" class="stepper-btn" data-dir="-1">v</button>
                        </div>
                    </div>
                </div>
                <div class="control-box" id="cm-box">
                    <label id="cm-label" class="control-tip" data-tip="Thrust coupling coefficient in N/MW (maps laser power to thrust).">Coupling Cm (N/MW)</label>
                    <div class="number-wrap">
                        <input type="number" id="cm-input" min="0" max="1000" step="0.000001" value="100" data-precision="auto">
                        <div class="stepper">
                            <button type="button" class="stepper-btn" data-dir="1">^</button>
                            <button type="button" class="stepper-btn" data-dir="-1">v</button>
                        </div>
                    </div>
                    <div class="toggle-row">
                        <span class="toggle-label control-tip" data-tip="Use radiation-pressure coupling (auto from reflectance).">Radiation Coupling</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="radiation-toggle">
                            <span class="toggle-track"></span>
                            <span class="toggle-knob"></span>
                        </label>
                    </div>
                </div>
                <div class="control-box">
                    <label for="reflectance-input" class="control-tip" data-tip="Fraction of laser power reflected by the sail (0 to 1).">Reflectance (0-1)</label>
                    <input type="number" id="reflectance-input" min="0" max="1" step="0.0001" value="0.1" data-precision="4">
                </div>
                <div class="control-box">
                    <label class="control-tip" data-tip="Thermal emissivity of the sail surface (0 to 1).">Emissivity (0-1)</label>
                    <input type="number" id="emissivity-input" min="0" max="1" step="0.001" value="0.92" data-precision="3">
                </div>
                <div class="control-box" id="absorptance-box">
                    <label class="control-tip" data-tip="Fixed absorptance if auto is off (0 to 1).">Absorptance (0-1)</label>
                    <div class="toggle-row">
                        <span class="toggle-label control-tip" data-tip="Derive absorptance as (1 - reflectance).">Auto Absorptance</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="absorptance-auto-toggle" checked>
                            <span class="toggle-track"></span>
                            <span class="toggle-knob"></span>
                        </label>
                    </div>
                    <div class="toggle-subfield" id="absorptance-input-wrap">
                        <input type="number" id="absorptance-input" min="0" max="1" step="0.000001" value="0.9" data-precision="auto">
                    </div>
                </div>
                <div class="control-box">
                    <label class="control-tip" data-tip="Destruction temperature limit for the active sail.">Temp Limit (K)</label>
                    <input type="number" id="temp-limit-input" min="1" max="10000" step="1" value="5000" data-precision="0">
                </div>
                <div class="control-box" id="irradiance-limit-box">
                    <label class="control-tip" data-tip="Maximum allowed peak irradiance (W/m).">Max I_peak (W/m)</label>
                    <div class="toggle-row">
                        <span class="toggle-label control-tip" data-tip="Auto-compute max irradiance limit from temp limit.">Auto I_limit</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="irradiance-auto-toggle" checked>
                            <span class="toggle-track"></span>
                            <span class="toggle-knob"></span>
                        </label>
                    </div>
                    <div class="toggle-subfield" id="irradiance-input-wrap">
                        <input type="number" id="irradiance-limit-input" min="0" max="1e13" step="1e6" value="8e9" data-precision="auto">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<div id="coupling-island" class="panel mobile-overlay">
    <div class="control-grid control-grid--stack">
        <div style="margin-bottom: 8px;">
            <div class="coupling-header-row">
                <div class="panel-title" data-tip="Coupling sets how laser power is controlled: manual output or auto-coupled to a target like temperature or irradiance.">Coupling</div>
                <button type="button" class="info-btn island-close-btn mobile-only-btn" aria-label="Close coupling controls">&times;</button>
            </div>
            <select id="coupling-mode" class="control-select">
                <option value="manual">Manual Power</option>
                <option value="temp">Sail Temp (K)</option>
                <option value="ipeak">Peak Irradiance</option>
                <option value="phit">P_hit (MW)</option>
                <option value="lambda">Wavelength (nm)</option>
            </select>
        </div>
        <div class="control-box is-hidden" id="coupling-target-box">
            <label id="coupling-target-label" for="coupling-target">Target</label>
            <div class="number-wrap">
                <input type="number" id="coupling-target" min="3" max="2000" step="1" value="200" data-precision="0">
                <div class="stepper">
                    <button type="button" class="stepper-btn" data-dir="1">^</button>
                    <button type="button" class="stepper-btn" data-dir="-1">v</button>
                </div>
            </div>
        </div>
    </div>
</div>

<div id="wavefront-island" class="panel mini-island mobile-overlay">
    <div class="telemetry-header" style="margin-bottom: 6px;">
        <span class="panel-title" data-tip="Visualizes the beam coherence and wavefront properties.">Wavefront Analysis</span>
        <div class="header-actions">
            <button type="button" class="info-btn island-close-btn mobile-only-btn" aria-label="Close wavefront analysis"></button>
            <button type="button" id="wavefront-info-btn" class="info-btn" aria-label="Wavefront details">!</button>
        </div>
    </div>
    <div class="wavefront-canvas-wrap">
        <canvas id="wave-canvas" style="width: 100%; height: 100%; display: block;"></canvas>
    </div>
    <div class="wavefront-footer">
        <div class="wavefront-meta">
            <div class="wavefront-meta-item">
                <span class="wavefront-meta-label">Source</span>
                <span id="wave-source-type" class="wavefront-meta-value">PHASED ARRAY</span>
            </div>
            <div class="wavefront-meta-item">
                <span class="wavefront-meta-label">Wave</span>
                <span id="wave-coherence" class="wavefront-meta-value">COHERENT</span>
            </div>
        </div>
        <div class="wavefront-bar" id="wavefront-bar">
            <div class="wavefront-bar-top">
                <span class="wavefront-bar-title">Wavelength Shift</span>
                <div class="wavefront-bar-values">
                    <span class="wavefront-bar-value" id="wave-lambda-source">450 nm</span>
                    <span class="wavefront-bar-value" id="wave-lambda-sail">450 nm</span>
                </div>
            </div>
            <div class="wavefront-bar-track">
                <div class="wavefront-bar-marker" id="wave-lambda-marker"></div>
            </div>
            <div class="wavefront-bar-labels">
                <span>Source</span>
                <span>Sail</span>
            </div>
        </div>
    </div>
</div>

<div id="mission-escape-island" class="panel mini-island mission-island">
    <div class="mission-toggle-group is-xerionyx" role="group" aria-label="Mission">
        <div class="mission-toggle-slider"></div>
        <button type="button" id="mission-xerionyx" class="mission-toggle-button is-active" aria-pressed="true" data-tip="Click to switch to XERIONYX mission defaults.">XERIONYX</button>
        <button type="button" id="mission-starshot" class="mission-toggle-button" aria-pressed="false" data-tip="Click to switch to STARSHOT mission defaults.">STARSHOT</button>
    </div>
    <div class="escape-row">
        <span class="escape-label" id="escape-label">Stop sim at Earth escape (OFF)</span>
        <button type="button" id="escape-toggle" class="escape-switch is-off" aria-pressed="false" aria-label="Stop sim at escape"></button>
    </div>
</div>

<div id="plot-island" class="panel mobile-overlay">
    <div class="plot-title" style="width: 100%;">
        <span class="control-tip" data-tip="Telemetry Plot: compare any two live simulation values over time or against each other.">Telemetry Plot</span>
        <div class="header-actions">
            <button type="button" class="info-btn island-close-btn mobile-only-btn" aria-label="Close plot"></button>
        </div>
    </div>
    <div class="plot-controls">
        <div>
            <label for="plot-x">X Axis</label>
            <select id="plot-x" class="control-select"></select>
        </div>
        <div>
            <label for="plot-y">Y Axis</label>
            <select id="plot-y" class="control-select"></select>
        </div>
        <button type="button" id="plot-download" class="plot-download" data-tip="Clicking this downloads a CSV file with 1000 X and Y axis data points.">Download CSV</button>
    </div>
    <canvas id="plot-canvas"></canvas>
<div id="plot-tooltip"></div>
</div>

<div id="extra-island" class="panel mobile-overlay desktop-hide">
    <div class="telemetry-header">
        <span>Extra Control</span>
        <div class="header-actions">
            <button type="button" class="info-btn island-close-btn mobile-only-btn" aria-label="Close extra controls"></button>
        </div>
    </div>
    <div id="extra-island-content" style="margin-top: 15px;"></div>
</div>

<canvas id="simCanvas"></canvas>

<div id="control-tooltip" aria-hidden="true"></div>

<div id="tutorial-overlay" class="tutorial-overlay" aria-hidden="true"></div>
<div id="tutorial-box" class="tutorial-box" aria-hidden="true">
    <div class="tutorial-text" id="tutorial-text"></div>
    <div class="tutorial-controls">
        <div style="display: flex; gap: 4px; flex: 1;">
            <button type="button" class="tutorial-skip-btn" id="tutorial-skip">Skip</button>
            <button type="button" class="tutorial-back-btn" id="tutorial-back" style="display:none;">Back</button>
        </div>
        <div style="display: flex; justify-content: center; flex: 1;">
            <button type="button" class="tutorial-learn-more-btn" id="tutorial-learn-more">Learn More</button>
        </div>
        <div style="display: flex; justify-content: flex-end; flex: 1;">
            <button type="button" class="tutorial-next-btn" id="tutorial-next">Next</button>
        </div>
    </div>
</div>

<div id="tutorial-info-box" class="tutorial-info-box" aria-hidden="true">
    <div class="tutorial-info-scroll">
        <div class="tutorial-info-content" id="tutorial-info-content">
            <!-- Dynamic Content -->
        </div>
        <button type="button" class="tutorial-info-close" id="tutorial-info-close">Close</button>
    </div>
</div>

<script>
/**
 * PHYSICAL CONSTANTS
 */
const C = 299792458;                 // Speed of light (m/s)
const G0 = 9.80665;                  // Sea level gravity (m/s2)
const RE = 6371000;                  // Earth radius (m)
const MU = G0 * RE * RE;             // Earth GM (m3/s2)
let LAMBDA = 450e-9;                 // 450nm (Blue)
const RS = 1.0;                      // Sail radius (m)
const DIAMETER = RS * 2;             // Characteristic length (m)
const MASS = 0.001;                  // Mass (kg)
const SAIL_AREA = Math.PI * RS * RS;
const SIGMA = 5.670374419e-8;        // Stefan-Boltzmann (W/m2K4)
const KB = 1.380649e-23;             // Boltzmann constant (J/K)
const AIR_DIAMETER = 3.7e-10;        // Effective air molecule diameter (m)
const R_SPEC = 287.05;               // Specific gas constant for air (J/kgK)
const GAMMA_AIR = 1.4;               // Ratio of specific heats for air
const CD_CONT = 2.0;                 // Continuum drag Cd
const CD_FM = 2.2;                   // Free-molecular Cd (slightly higher)
const R_LASER = 0.1;                 // Low reflectance (we want to absorb!)
const A_LASER = 0.9;                 // High absorptance (Black Plastic)
const T_LASER = Math.max(0, 1 - R_LASER - A_LASER); // Transmittance (>=0)
const EPS_RAD = 0.92;                // Emissivity placeholder (engineered mid-IR)
const CP = 1000;                     // Effective heat capacity (J/kgK)
const T_SPACE = 3;                   // Space background temp (K)
const RHO_ENV = 1e-5;                // Density for space/atmosphere radiative blend (kg/m3)
const H_CONV0 = 8;                   // Sea-level convective h (W/m2K)
const H_CONV_POW = 0.5;              // Density exponent for convective h
const T_MAX = 5000;                  // Overheat threshold (K)
const ATM_TRANSMISSION_ZENITH = 0.6; // 60% of blue light makes it to space
const I_MAX = 8000e6;                 // Irradiance limit (W/m2) ~150 MW/m2 (applied to peak)
const I_PEAK_MARGIN = 0.98;          // Target fraction of peak irradiance limit
const AERO_K = 1.83e-4;              // Aero heating coefficient
const RN = 0.5;                      // Nose radius for heating proxy (m)
const BEAM_QUALITY = 0.85;           // Strehl/quality factor (<1 grows spot)
const USE_AIRY_MODEL = false;        // Option A default (Gaussian-equivalent)
const USD_PER_KWH = 0.16;            // Energy price
const RHO0 = 1.225;                  // Sea level density (kg/m3) for visuals
const W_FLOOR = 0.0001;                 // Turbulence/seeing floor for spot radius (m)
const H0 = 48000;                    // Start altitude (m)
const MAX_DV_PER_STEP = 5;           // Limit velocity change per substep (m/s)
const MAX_SUBSTEPS = 120;            // Base cap substeps per physics tick for stability
const MAX_SUBSTEPS_THERMAL = 800;    // Allow more substeps when thermal stability needs it
const DRAG_DT_SAFETY = 0.9;          // Safety factor for drag-stiff timestep limit
const MAX_DTEMP_PER_STEP = 25;       // Limit temperature change per substep (K)
const THERMAL_DT_SAFETY = 0.5;       // Safety factor for thermal stability timestep
const ABLATION_PABS_OFF_MW = 0.001;  // Below this absorbed power, no particles
const ABLATION_PABS_ON_MW = 0.01;    // At/above this absorbed power, max particles
const ABLATION_PARTICLE_MAX = 200;   // Max particle count at threshold
const ABLATION_PARTICLE_LIFE = 0.9;  // Base particle lifetime (s)
const ABLATION_PARTICLE_SPREAD = Math.PI * 0.9; // Downward cone spread (radians)
const EXPLOSION_PARTICLE_COUNT = 220;
const EXPLOSION_PARTICLE_LIFE = 1.6;
const EXPLOSION_PARTICLE_SPEED = 260;

/**
 * STATE
 */
let h = H0;                 // Altitude (m)
let v = 0;                  // Velocity (m/s)
let tempK = 300;            // Sail temperature (K)
let laserOn = false;
let powerMW = 0.07;
let apertureD = 4;
let startAltitude = H0;
let massKg = MASS;
let reflectance = R_LASER;
let absorptance = clamp01(1 - reflectance);
let emissivity = EPS_RAD;
let atmTransmissionZenith = ATM_TRANSMISSION_ZENITH;
let absorptanceFromReflectance = true;
let maxIrradianceLimit = I_MAX;
let tempLimitK = T_MAX;
let autoIrradianceLimit = false;
let beamQuality = BEAM_QUALITY;
let wFloor = W_FLOOR;
let sailDiameter = DIAMETER;
let sailRadius = RS;
let sailArea = SAIL_AREA;
let beamRadiusOverride = 0;
let couplingCm = 100; // N/MW
let divergenceMrad = 0.01;
let couplingMode = "manual";
let couplingTarget = 200;
let stopOnEscape = false;
let useDiffractionBeam = false;
let useRadiationCoupling = false;
let divergenceLocked = false;
let divergenceSyncing = false;
let beamRadiusSyncing = false;
let simPaused = false;
let simStarted = false;
let statusText = "OK";
let timeScale = 1;
let simElapsed = 0;
let simAccumulator = 0;
let energyCostUSD = 0;
let impulseNs = 0;
let energyHitJ = 0;
let energyAbsJ = 0;
let inputHold = false;
let lastTelemetry = null;
let lastPhysResult = { wEff: wFloor, rho: RHO0 };
const plotSamples = [];
let lastPlotSampleTime = -1;
const PLOT_SAMPLE_DT = 0.02;
const PLOT_MAX_SAMPLES = 0;
const CSV_SAMPLE_COUNT = 1000;
let plotDpr = window.devicePixelRatio || 1;
const ablationParticles = [];
let ablationSpawnAccumulator = 0;
let ablationLastStamp = performance.now();
const explosionParticles = [];
let explosionPending = false;
let explosionShock = 0;
let explosionLastStamp = performance.now();
let explosionOrigin = { x: 0, y: 0 };
let sailFailed = false;

// Canvas Setup
const canvas = document.getElementById('simCanvas');
const ctx = canvas.getContext('2d');
let width, height;

function resize() {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
    syncTelemetryHeight();
}
window.addEventListener('resize', resize);
resize();

const mobileQuery = window.matchMedia('(max-width: 820px)');
function updateViewportHeight() {
    const vv = window.visualViewport;
    const visualHeight = vv ? vv.height : window.innerHeight;
    const offsetTop = vv ? vv.offsetTop : 0;
    const layoutHeight = document.documentElement.clientHeight || window.innerHeight;
    const baseBottomInset = Math.max(0, layoutHeight - (visualHeight + offsetTop));

    document.documentElement.style.setProperty('--vh', `${visualHeight * 0.01}px`);
    document.documentElement.style.setProperty('--browser-bottom', `${baseBottomInset}px`);

    const controlsIsland = document.getElementById('controls-island');
    if (!controlsIsland) return;

    requestAnimationFrame(() => {
        const rect = controlsIsland.getBoundingClientRect();
        const visualBottom = offsetTop + visualHeight;
        const overflow = Math.max(0, rect.bottom - visualBottom + 4);
        const nextInset = Math.max(baseBottomInset, overflow);
        document.documentElement.style.setProperty('--browser-bottom', `${nextInset}px`);
    });
}
function applyMobileClass() {
    const isMobile = mobileQuery.matches;
    document.body.classList.toggle('is-mobile', isMobile);
    document.documentElement.classList.toggle('is-mobile', isMobile);
    updateViewportHeight();
}
applyMobileClass();
window.addEventListener('resize', updateViewportHeight);
window.addEventListener('orientationchange', updateViewportHeight);
if (window.visualViewport) {
    window.visualViewport.addEventListener('resize', updateViewportHeight);
    window.visualViewport.addEventListener('scroll', updateViewportHeight);
}
mobileQuery.addEventListener('change', applyMobileClass);

const pageLoader = document.getElementById('page-loader');
const loaderState = {
    shownAt: 0,
    showTimer: null,
    loadFinished: false
};
const loaderConfig = {
    showDelayMs: 120,
    minVisibleMs: 650
};

function areImagesCached() {
    const images = Array.from(document.images);
    if (images.length === 0) return true;
    return images.every((img) => img.complete && img.naturalWidth > 0);
}

function showPageLoader() {
    if (!pageLoader || loaderState.shownAt) return;
    pageLoader.classList.add('is-visible');
    pageLoader.setAttribute('aria-hidden', 'false');
    loaderState.shownAt = performance.now();
}

function removePageLoader() {
    if (pageLoader && pageLoader.parentNode) {
        pageLoader.parentNode.removeChild(pageLoader);
    }
}

function hidePageLoader() {
    if (!pageLoader) return;
    pageLoader.classList.remove('is-visible');
    pageLoader.setAttribute('aria-hidden', 'true');
    window.setTimeout(() => {
        removePageLoader();
    }, 220);
}

function initPageLoader() {
    if (!pageLoader) return;
    if (areImagesCached()) {
        removePageLoader();
        return;
    }
    loaderState.showTimer = window.setTimeout(() => {
        if (!loaderState.loadFinished) {
            showPageLoader();
        }
    }, loaderConfig.showDelayMs);
    window.addEventListener('load', () => {
        loaderState.loadFinished = true;
        if (!pageLoader) return;
        if (!loaderState.shownAt) {
            if (loaderState.showTimer) {
                window.clearTimeout(loaderState.showTimer);
            }
            removePageLoader();
            return;
        }
        const elapsed = performance.now() - loaderState.shownAt;
        const remaining = Math.max(0, loaderConfig.minVisibleMs - elapsed);
        window.setTimeout(hidePageLoader, remaining);
    });
}

initPageLoader();

// UI Elements
const pSlider = document.getElementById('power-slider');
const dSlider = document.getElementById('aperture-slider');
const pModeDisp = document.getElementById('p-mode');
const speedSlider = document.getElementById('speed-slider');
const altitudeSlider = document.getElementById('altitude-slider');
const beamRadiusInput = document.getElementById('beam-radius-input');
const wavelengthInput = document.getElementById('wavelength-input');
const sailDiameterInput = document.getElementById('sail-diameter-input');
const cmInput = document.getElementById('cm-input');
const cmLabel = document.getElementById('cm-label');
const cmBox = document.getElementById('cm-box');
const divInput = document.getElementById('div-input');
const divLabel = document.getElementById('div-label');
const massInput = document.getElementById('mass-input');
const reflectanceInput = document.getElementById('reflectance-input');
const emissivityInput = document.getElementById('emissivity-input');
const transmissionInput = document.getElementById('transmission-input');
const beamQualityInput = document.getElementById('beam-quality-input');
const spotFloorInput = document.getElementById('spot-floor-input');
const tempLimitInput = document.getElementById('temp-limit-input');
const irradianceLimitInput = document.getElementById('irradiance-limit-input');
const irradianceAutoToggle = document.getElementById('irradiance-auto-toggle');
const irradianceInputWrap = document.getElementById('irradiance-input-wrap');
const absorptanceInput = document.getElementById('absorptance-input');
const absorptanceAutoToggle = document.getElementById('absorptance-auto-toggle');
const absorptanceInputWrap = document.getElementById('absorptance-input-wrap');
const diffractionToggle = document.getElementById('diffraction-toggle');
const radiationToggle = document.getElementById('radiation-toggle');
const couplingModeSelect = document.getElementById('coupling-mode');
const couplingTargetInput = document.getElementById('coupling-target');
const couplingTargetLabel = document.getElementById('coupling-target-label');
const couplingTargetBox = document.getElementById('coupling-target-box');
const escapeLabel = document.getElementById('escape-label');
const escapeToggleBtn = document.getElementById('escape-toggle');
const missionXerionyxBtn = document.getElementById('mission-xerionyx');
const missionStarshotBtn = document.getElementById('mission-starshot');
const sailPanelTitle = document.getElementById('sail-panel-title');
const realTimeDisp = document.getElementById('tel-real');
const costDisp = document.getElementById('tel-cost');
const toggleBtn = document.getElementById('toggle-btn');
const pauseBtn = document.getElementById('pause-btn');
const restartBtn = document.getElementById('restart-btn');
const telH = document.getElementById('tel-h');
const telRange = document.getElementById('tel-range');
const telV = document.getElementById('tel-v');
const telA = document.getElementById('tel-a');
const telVc = document.getElementById('tel-vc');
const telLambda = document.getElementById('tel-lambda');
const telPemit = document.getElementById('tel-pemit');
const telPhit = document.getElementById('tel-phit');
const telIrr = document.getElementById('tel-irr');
const telIrr0 = document.getElementById('tel-irr0');
const telPabs = document.getElementById('tel-pabs');
const telW = document.getElementById('tel-w');
const telAng = document.getElementById('tel-ang');
const telPtol = document.getElementById('tel-ptol');
const telBratio = document.getElementById('tel-bratio');
const telFhit = document.getElementById('tel-fhit');
const telFl = document.getElementById('tel-fl');
const telFd = document.getElementById('tel-fd');
const telQ = document.getElementById('tel-q');
const telMach = document.getElementById('tel-mach');
const telRe = document.getElementById('tel-re');
const telTstag = document.getElementById('tel-tstag');
const telQdot = document.getElementById('tel-qdot');
const telRho = document.getElementById('tel-rho');
const telTemp = document.getElementById('tel-temp');
const telVe = document.getElementById('tel-ve');
const telIsp = document.getElementById('tel-isp');
const telImp = document.getElementById('tel-imp');
const telEhit = document.getElementById('tel-ehit');
const telEabs = document.getElementById('tel-eabs');
const telEps = document.getElementById('tel-eps');
const telStatus = document.getElementById('tel-status');
const plotIsland = document.getElementById('plot-island');
const plotCanvas = document.getElementById('plot-canvas');
const plotCtx = plotCanvas.getContext('2d');
const plotXSelect = document.getElementById('plot-x');
const plotYSelect = document.getElementById('plot-y');
const plotDownloadBtn = document.getElementById('plot-download');
const controlTooltip = document.getElementById('control-tooltip');
const plotTooltip = document.getElementById('plot-tooltip');
const plotHover = { x: 0, y: 0, active: false };
const numberInputs = document.querySelectorAll('.control-box input[type="number"]');
const telemetryInfoBtn = document.getElementById('telemetry-info-btn');
const wavefrontInfoBtn = document.getElementById('wavefront-info-btn');
const mainControlInfoBtn = document.getElementById('main-control-info-btn');


function isPaused() {
    return simPaused || inputHold;
}

function updateInputHold() {
    inputHold = Array.from(numberInputs).some((input) => !input.disabled && input.value.trim() === "");
}

function applyStartAltitude(value) {
    if (!Number.isFinite(value)) return;
    startAltitude = value;
    if (!laserOn) {
        h = startAltitude;
        v = 0;
        tempK = atmosphereState(startAltitude).T;
    }
}

function clamp01(value) {
    return Math.min(1, Math.max(0, value));
}

function applyMass(value) {
    if (!Number.isFinite(value) || value <= 0) return;
    massKg = value;
}

function applyCouplingCm(value) {
    if (!Number.isFinite(value) || value < 0) return;
    couplingCm = value;
}

function applyDivergence(value) {
    if (!Number.isFinite(value) || value < 0) return;
    divergenceMrad = value;
}

function computeRadiationCouplingCm() {
    return ((2 * reflectance + absorptance) / C) * 1e6;
}

function syncRadiationCoupling() {
    if (!useRadiationCoupling) return;
    couplingCm = computeRadiationCouplingCm();
    if (cmInput) {
        setNumberInputValue(cmInput, couplingCm);
    }
}

function updateSailControlUi() {
    if (!cmLabel || !cmInput || !cmBox) return;
    if (useRadiationCoupling) {
        cmLabel.textContent = "Coupling (auto from reflectance)";
        cmInput.disabled = true;
        syncRadiationCoupling();
    } else {
        cmLabel.textContent = "Coupling Cm (N/MW)";
        cmInput.disabled = false;
    }
    cmBox.classList.remove("is-hidden");
}

function computeDiffractionDivergenceMrad() {
    const aperture = Math.max(apertureD, 1e-9);
    const airyBase = 1.22 * LAMBDA / aperture;
    const factor = USE_AIRY_MODEL ? 1 : (1.05 / Math.sqrt(Math.max(beamQuality, 1e-9)));
    return airyBase * factor * 1000;
}

function syncDiffractionDivergence() {
    if (!divInput) return;
    if (useDiffractionBeam && divergenceLocked) {
        const divMrad = computeDiffractionDivergenceMrad();
        divergenceMrad = divMrad;
        if (divLabel) {
            divLabel.textContent = "Beam Divergence (mrad, diffraction)";
        }
        divergenceSyncing = true;
        setNumberInputValue(divInput, divMrad);
        divergenceSyncing = false;
    } else {
        if (divLabel) {
            divLabel.textContent = "Beam Divergence (mrad)";
        }
    }
}

function applyReflectance(value) {
    if (!Number.isFinite(value)) return;
    reflectance = clamp01(value);
    if (absorptanceFromReflectance) {
        absorptance = clamp01(1 - reflectance);
        if (absorptanceInput) {
            setNumberInputValue(absorptanceInput, absorptance, true);
        }
        if (autoIrradianceLimit) {
            maxIrradianceLimit = tempLimitedIrradiance(tempLimitK);
        }
    }
    syncRadiationCoupling();
}

function applyEmissivity(value) {
    if (!Number.isFinite(value)) return;
    emissivity = clamp01(value);
    if (autoIrradianceLimit) {
        maxIrradianceLimit = tempLimitedIrradiance(tempLimitK);
    }
}

function applyTransmission(value) {
    if (!Number.isFinite(value)) return;
    atmTransmissionZenith = clamp01(value);
}

function applyBeamQuality(value) {
    if (!Number.isFinite(value)) return;
    beamQuality = clampValue(value, 0.05, 1);
    syncDiffractionDivergence();
}

function applySpotFloor(value) {
    if (!Number.isFinite(value)) return;
    wFloor = Math.max(0, value);
    if (lastPhysResult) {
        lastPhysResult.wEff = Math.max(lastPhysResult.wEff, wFloor);
    }
}

function applyTempLimit(value) {
    if (!Number.isFinite(value)) return;
    tempLimitK = Math.max(1, value);
    if (autoIrradianceLimit) {
        maxIrradianceLimit = tempLimitedIrradiance(tempLimitK);
    }
}

function applyMaxIrradiance(value) {
    if (!Number.isFinite(value)) return;
    maxIrradianceLimit = Math.max(0, value);
}

function applyAbsorptance(value) {
    if (!Number.isFinite(value)) return;
    absorptance = clamp01(value);
    if (useRadiationCoupling) {
        syncRadiationCoupling();
    }
    if (autoIrradianceLimit) {
        maxIrradianceLimit = tempLimitedIrradiance(tempLimitK);
    }
}

function updateAbsorptanceUi() {
    if (!absorptanceAutoToggle || !absorptanceInput) return;
    absorptanceFromReflectance = absorptanceAutoToggle.checked;
    if (absorptanceFromReflectance) {
        absorptance = clamp01(1 - reflectance);
        absorptanceInput.disabled = true;
        setNumberInputValue(absorptanceInput, absorptance, true);
        if (absorptanceInputWrap) absorptanceInputWrap.classList.add("is-hidden");
    } else {
        absorptanceInput.disabled = false;
        if (absorptanceInputWrap) absorptanceInputWrap.classList.remove("is-hidden");
        applyAbsorptance(parseFloat(absorptanceInput.value));
    }
    syncRadiationCoupling();
}

function updateIrradianceUi() {
    if (!irradianceAutoToggle) return;
    autoIrradianceLimit = irradianceAutoToggle.checked;
    if (autoIrradianceLimit) {
        maxIrradianceLimit = tempLimitedIrradiance(tempLimitK);
        if (irradianceLimitInput) {
            setNumberInputValue(irradianceLimitInput, maxIrradianceLimit, true);
            irradianceLimitInput.disabled = true;
        }
        if (irradianceInputWrap) irradianceInputWrap.classList.add("is-hidden");
    } else {
        if (irradianceLimitInput) {
            irradianceLimitInput.disabled = false;
            applyMaxIrradiance(parseFloat(irradianceLimitInput.value));
        }
        if (irradianceInputWrap) irradianceInputWrap.classList.remove("is-hidden");
    }
}

function applyDiffractionToggle(value) {
    useDiffractionBeam = !!value;
    divergenceLocked = useDiffractionBeam;
    syncDiffractionDivergence();
}

function applyRadiationToggle(value) {
    useRadiationCoupling = !!value;
    updateSailControlUi();
    syncRadiationCoupling();
}

function applySailDiameter(value) {
    if (!Number.isFinite(value) || value <= 0) return;
    sailDiameter = value;
    sailRadius = sailDiameter / 2;
    sailArea = Math.PI * sailRadius * sailRadius;
}

function applyWavelengthNm(value) {
    if (!Number.isFinite(value) || value <= 0) return;
    LAMBDA = value * 1e-9;
    syncDiffractionDivergence();
}

function applyBeamRadiusOverride(value) {
    if (!Number.isFinite(value) || value < 0) return;
    beamRadiusOverride = value;
}

const couplingPresets = {
    manual: { label: "Target", min: 0, max: 0, step: 1, value: 0, disabled: true },
    temp: { label: "Target Temp (K)", min: 3, max: 2000, step: 1, value: 200, disabled: false },
    ipeak: { label: "Target I_peak (W/m2)", min: 1, max: 1e12, step: 1e6, value: 1e9, disabled: false },
    phit: { label: "Target P_hit (MW)", min: 0, max: 1000, step: 0.1, value: 10, disabled: false },
    lambda: { label: "Target _sail (nm)", min: 200, max: 2000, step: 1, value: 450, disabled: false }
};

function applyCouplingTarget(value) {
    if (!Number.isFinite(value)) return;
    couplingTarget = value;
}

function updateCouplingUi(mode) {
    const preset = couplingPresets[mode] || couplingPresets.manual;
    couplingMode = mode;
    const targetHidden = couplingMode === "manual";
    couplingTargetLabel.textContent = preset.label;
    couplingTargetInput.min = preset.min;
    couplingTargetInput.max = preset.max;
    couplingTargetInput.step = preset.step;
    couplingTargetInput.disabled = preset.disabled;
    if (couplingTargetBox) {
        couplingTargetBox.classList.toggle("is-hidden", targetHidden);
    }
    if (!couplingTargetInput.disabled) {
        let nextValue = preset.value;
        const dataNow = computeForces();
    if (couplingMode === "phit") {
        nextValue = dataNow.pHit / 1e6;
    } else if (couplingMode === "ipeak") {
        nextValue = dataNow.irradiance0;
    } else if (couplingMode === "temp") {
        nextValue = tempK;
    } else if (couplingMode === "lambda") {
        nextValue = observedLambdaNm(v);
    }
        setNumberInputValue(couplingTargetInput, nextValue, true);
        applyCouplingTarget(parseFloat(couplingTargetInput.value));
    } else {
        if (couplingTargetInput.value.trim() === "") {
            couplingTargetInput.value = preset.value;
        }
        applyCouplingTarget(parseFloat(couplingTargetInput.value));
    }
    updateInputHold();
}

const missionPresets = {
    atmosphere: {
        label: "XERIONYX (48 km)",
        startAltitude: 48000,
        wavelength: 450e-9,
        apertureD: 4,
        powerMW: 0.07,
        divergenceMrad: 0.01,
        massKg: 0.001,
        sailDiameter: 2,
        couplingCm: 100,
        reflectance: 0.1,
        absorptance: 0.9,
        emissivity: EPS_RAD,
        beamQuality: BEAM_QUALITY,
        wFloor: W_FLOOR,
        transmission: ATM_TRANSMISSION_ZENITH,
        absorptanceFromReflectance: true,
        maxIrradiance: I_MAX,
        tempLimitK: T_MAX,
        beamRadiusOverride: 0,
        useDiffractionBeam: false,
        useRadiationCoupling: false
    },
    starshot: {
        label: "Starshot (60,000 km)",
        startAltitude: 60000000,
        wavelength: 1064e-9,
        apertureD: 2700,
        powerMW: 200000,
        divergenceMrad: 0,
        massKg: 0.0036,
        sailDiameter: 4.1,
        couplingCm: 0.0067,
        reflectance: 0.7,
        absorptance: 1e-8,
        emissivity: 0.01,
        beamQuality: BEAM_QUALITY,
        wFloor: W_FLOOR,
        transmission: 0.7,
        absorptanceFromReflectance: false,
        maxIrradiance: "auto",
        tempLimitK: 625,
        beamRadiusOverride: 0,
        useDiffractionBeam: true,
        useRadiationCoupling: true
    }
};

let activeMissionKey = "atmosphere";

function setNumberInputValue(input, value, silent = false) {
    if (!input) return;
    const precisionAttr = input.getAttribute("data-precision");
    const toAutoFixed = (num, sigDigits = 6, minDec = 2, maxDec = 9) => {
        if (!Number.isFinite(num)) return "";
        const abs = Math.abs(num);
        if (abs > 0 && (abs < 1e-4 || abs >= 1e6)) {
            return num.toExponential(6);
        }
        let decimals = minDec;
        if (abs === 0) {
            decimals = Math.max(minDec, Math.min(maxDec, sigDigits));
        } else {
            const order = Math.floor(Math.log10(abs));
            decimals = sigDigits - 1 - order;
            decimals = Math.max(minDec, Math.min(maxDec, decimals));
        }
        const text = num.toFixed(decimals);
        return text.replace(/(\.\d*?[1-9])0+$/u, "$1").replace(/\.0+$/u, "");
    };
    if (precisionAttr) {
        if (precisionAttr === "auto") {
            input.value = toAutoFixed(Number(value));
            if (!silent) {
                input.dispatchEvent(new Event("input", { bubbles: true }));
            }
            return;
        }
        const precision = parseInt(precisionAttr, 10);
        if (Number.isFinite(precision)) {
            const numeric = Number(value);
            let text = numeric.toFixed(precision);
            text = text.replace(/(\.\d*?[1-9])0+$/u, "$1").replace(/\.0+$/u, "");
            input.value = text;
            if (!silent) {
                input.dispatchEvent(new Event("input", { bubbles: true }));
            }
            return;
        }
    }
    input.value = value;
    if (!silent) {
        input.dispatchEvent(new Event("input", { bubbles: true }));
    }
}

function formatAllNumberInputs() {
    numberInputs.forEach((input) => {
        if (input.disabled) return;
        if (input.value.trim() === "") return;
        setNumberInputValue(input, parseFloat(input.value));
    });
}

function setSelectValue(select, value) {
    if (!select) return;
    select.value = value;
    select.dispatchEvent(new Event("change", { bubbles: true }));
}

function resetSimulationState() {
    simPaused = false;
    statusText = "OK";
    simStarted = false;
    sailFailed = false;
    simElapsed = 0;
    simAccumulator = 0;
    laserOn = false;
    toggleBtn.textContent = "START LASER";
    toggleBtn.classList.remove('active');
    v = 0;
    h = startAltitude;
    tempK = atmosphereState(startAltitude).T;
    energyCostUSD = 0;
    impulseNs = 0;
    energyHitJ = 0;
    energyAbsJ = 0;
    plotSamples.length = 0;
    lastPlotSampleTime = -1;
    ablationParticles.length = 0;
    ablationSpawnAccumulator = 0;
    ablationLastStamp = performance.now();
    explosionParticles.length = 0;
    explosionPending = false;
    explosionShock = 0;
    lastPhysResult = updatePhysics(0);
}

function updateMissionButton() {
    const preset = missionPresets[activeMissionKey];
    if (!missionXerionyxBtn || !missionStarshotBtn || !preset) return;
    const isAtmosphere = activeMissionKey === "atmosphere";
    missionXerionyxBtn.classList.toggle("is-active", isAtmosphere);
    missionXerionyxBtn.setAttribute("aria-pressed", isAtmosphere ? "true" : "false");
    missionStarshotBtn.classList.toggle("is-active", !isAtmosphere);
    missionStarshotBtn.setAttribute("aria-pressed", !isAtmosphere ? "true" : "false");
    
    const missionGroup = missionXerionyxBtn.parentElement;
    if (missionGroup) {
        missionGroup.classList.toggle("is-xerionyx", isAtmosphere);
        missionGroup.classList.toggle("is-starshot", !isAtmosphere);
    }

    if (sailPanelTitle) {
        const title = isAtmosphere ? "Ablative Sail" : "Dielectric Sail";
        sailPanelTitle.textContent = title;
        sailPanelTitle.setAttribute(
            "data-tip",
            isAtmosphere
                ? "Ablative sail parameters: thrust coupling, reflectance, divergence, and mass for the atmospheric mission."
                : "Dielectric sail parameters: reflectance-driven coupling and mass for the Starshot mission."
        );
    }
}

function updateEscapeButton() {
    if (!escapeToggleBtn) return;
    escapeToggleBtn.classList.toggle("is-on", stopOnEscape);
    escapeToggleBtn.classList.toggle("is-off", !stopOnEscape);
    escapeToggleBtn.setAttribute("aria-pressed", stopOnEscape ? "true" : "false");
    if (escapeLabel) {
        escapeLabel.textContent = `Stop sim at Earth escape (${stopOnEscape ? "ON" : "OFF"})`;
    }
}

function applyMissionPreset(key) {
    const preset = missionPresets[key];
    if (!preset) return;
    activeMissionKey = key;
    LAMBDA = preset.wavelength;
    useDiffractionBeam = preset.useDiffractionBeam;
    useRadiationCoupling = preset.useRadiationCoupling;
    absorptanceFromReflectance = preset.absorptanceFromReflectance ?? absorptanceFromReflectance;
    emissivity = preset.emissivity ?? emissivity;
    beamQuality = preset.beamQuality ?? beamQuality;
    wFloor = preset.wFloor ?? wFloor;
    atmTransmissionZenith = preset.transmission ?? atmTransmissionZenith;
    if (Number.isFinite(preset.tempLimitK)) {
        tempLimitK = preset.tempLimitK;
    }
    divergenceLocked = useDiffractionBeam;

    setNumberInputValue(altitudeSlider, preset.startAltitude);
    setNumberInputValue(pSlider, preset.powerMW);
    setNumberInputValue(dSlider, preset.apertureD);
    if (!useDiffractionBeam) {
        setNumberInputValue(divInput, preset.divergenceMrad);
    }
    setNumberInputValue(wavelengthInput, preset.wavelength * 1e9);
    setNumberInputValue(massInput, preset.massKg);
    setNumberInputValue(sailDiameterInput, preset.sailDiameter);
    if (!useRadiationCoupling) {
        setNumberInputValue(cmInput, preset.couplingCm);
    }
    setNumberInputValue(beamRadiusInput, preset.beamRadiusOverride);
    setNumberInputValue(reflectanceInput, preset.reflectance);
    if (emissivityInput) setNumberInputValue(emissivityInput, emissivity, true);
    if (transmissionInput) setNumberInputValue(transmissionInput, atmTransmissionZenith, true);
    if (beamQualityInput) setNumberInputValue(beamQualityInput, beamQuality, true);
    if (spotFloorInput) setNumberInputValue(spotFloorInput, wFloor, true);
    if (tempLimitInput) setNumberInputValue(tempLimitInput, tempLimitK, true);

    reflectance = clamp01(preset.reflectance);
    if (absorptanceFromReflectance) {
        absorptance = clamp01(1 - reflectance);
    } else if (typeof preset.absorptance === "number") {
        absorptance = clamp01(preset.absorptance);
    }
    if (preset.maxIrradiance === "auto") {
        autoIrradianceLimit = true;
        maxIrradianceLimit = tempLimitedIrradiance(preset.tempLimitK);
    } else if (Number.isFinite(preset.maxIrradiance)) {
        autoIrradianceLimit = false;
        maxIrradianceLimit = preset.maxIrradiance;
    } else {
        autoIrradianceLimit = false;
        maxIrradianceLimit = Infinity;
    }
    syncRadiationCoupling();
    if (absorptanceInput) setNumberInputValue(absorptanceInput, absorptance, true);
    if (irradianceLimitInput) setNumberInputValue(irradianceLimitInput, maxIrradianceLimit, true);
    if (absorptanceAutoToggle) absorptanceAutoToggle.checked = absorptanceFromReflectance;
    if (irradianceAutoToggle) irradianceAutoToggle.checked = autoIrradianceLimit;
    if (diffractionToggle) diffractionToggle.checked = useDiffractionBeam;
    if (radiationToggle) radiationToggle.checked = useRadiationCoupling;
    updateAbsorptanceUi();
    updateIrradianceUi();

    updateSailControlUi();
    syncDiffractionDivergence();
    resetSimulationState();
    updateMissionButton();
}

function getStepValue(input) {
    const stepAttr = input.getAttribute("step");
    if (!stepAttr || stepAttr === "any") return 1;
    const step = parseFloat(stepAttr);
    return Number.isFinite(step) && step > 0 ? step : 1;
}

function getStepPrecision(input) {
    const stepAttr = input.getAttribute("step");
    if (!stepAttr || stepAttr === "any") return 0;
    const dot = stepAttr.indexOf(".");
    return dot === -1 ? 0 : stepAttr.length - dot - 1;
}

function clampValue(value, min, max) {
    let v = value;
    if (Number.isFinite(min)) v = Math.max(v, min);
    if (Number.isFinite(max)) v = Math.min(v, max);
    return v;
}

function adjustNumberInput(input, dir, scale = 1) {
    if (!input) return;
    const step = getStepValue(input) * Math.max(1, scale);
    const precision = getStepPrecision(input);
    const minAttr = parseFloat(input.getAttribute("min"));
    const maxAttr = parseFloat(input.getAttribute("max"));
    let value = parseFloat(input.value);
    if (!Number.isFinite(value)) value = 0;
    value = clampValue(value + dir * step, minAttr, maxAttr);
    if (precision > 0) {
        value = parseFloat(value.toFixed(precision));
    }
    input.value = value;
    input.dispatchEvent(new Event("input", { bubbles: true }));
}

function setupNumberControls() {
    numberInputs.forEach((input) => {
        input.addEventListener("input", () => {
            updateInputHold();
            if (input === speedSlider) {
                const minAttr = parseFloat(input.getAttribute("min"));
                const maxAttr = parseFloat(input.getAttribute("max"));
                const value = parseFloat(input.value);
                if (Number.isFinite(value)) {
                    const clamped = clampValue(value, minAttr, maxAttr);
                    if (clamped !== value) {
                        input.value = clamped;
                    }
                }
            }
            if (input === emissivityInput || input === transmissionInput || input === beamQualityInput
                || input === spotFloorInput || input === tempLimitInput || input === irradianceLimitInput
                || input === absorptanceInput) {
                const minAttr = parseFloat(input.getAttribute("min"));
                const maxAttr = parseFloat(input.getAttribute("max"));
                const value = parseFloat(input.value);
                if (Number.isFinite(value)) {
                    const clamped = clampValue(value, minAttr, maxAttr);
                    if (clamped !== value) {
                        input.value = clamped;
                    }
                }
            }
            if (input === altitudeSlider) {
                const value = parseFloat(input.value);
                if (!Number.isFinite(value) && input.value.trim() === "-") {
                    input.value = "";
                } else if (Number.isFinite(value) && value < 0) {
                    input.value = "0";
                }
                applyStartAltitude(parseFloat(input.value));
            } else if (input === beamRadiusInput) {
                if (beamRadiusSyncing) return;
                applyBeamRadiusOverride(parseFloat(input.value));
            } else if (input === wavelengthInput) {
                applyWavelengthNm(parseFloat(input.value));
            } else if (input === massInput) {
                applyMass(parseFloat(input.value));
            } else if (input === cmInput) {
                applyCouplingCm(parseFloat(input.value));
            } else if (input === divInput) {
                if (divergenceSyncing) return;
                applyDivergence(parseFloat(input.value));
                if (useDiffractionBeam && divergenceLocked) {
                    divergenceLocked = false;
                    useDiffractionBeam = false;
                    syncDiffractionDivergence();
                }
            } else if (input === reflectanceInput) {
                applyReflectance(parseFloat(input.value));
            } else if (input === sailDiameterInput) {
                applySailDiameter(parseFloat(input.value));
            } else if (input === couplingTargetInput) {
                applyCouplingTarget(parseFloat(input.value));
            } else if (input === emissivityInput) {
                applyEmissivity(parseFloat(input.value));
            } else if (input === transmissionInput) {
                applyTransmission(parseFloat(input.value));
            } else if (input === beamQualityInput) {
                applyBeamQuality(parseFloat(input.value));
            } else if (input === spotFloorInput) {
                applySpotFloor(parseFloat(input.value));
            } else if (input === tempLimitInput) {
                applyTempLimit(parseFloat(input.value));
                if (autoIrradianceLimit) {
                    updateIrradianceUi();
                }
            } else if (input === irradianceLimitInput) {
                if (!autoIrradianceLimit) {
                    applyMaxIrradiance(parseFloat(input.value));
                }
            } else if (input === absorptanceInput) {
                if (!absorptanceFromReflectance) {
                    applyAbsorptance(parseFloat(input.value));
                }
            }
        });
        input.addEventListener("blur", () => {
            if (input.disabled) return;
            if (input.value.trim() === "") return;
            setNumberInputValue(input, parseFloat(input.value));
        });
        input.addEventListener("blur", updateInputHold);
        
        // Fix for mobile Safari layout shift after keyboard close
        input.addEventListener("blur", () => {
             window.scrollTo(0, 0);
             if (typeof updateViewportHeight === 'function') {
                 setTimeout(updateViewportHeight, 60);
                 setTimeout(updateViewportHeight, 300);
             }
        });

        input.addEventListener("wheel", (event) => {
            event.preventDefault();
            if (input.disabled) return;
            const dir = event.deltaY < 0 ? 1 : -1;
            adjustNumberInput(input, dir);
        }, { passive: false });
    });

    const steppers = document.querySelectorAll(".stepper-btn");
    steppers.forEach((btn) => {
        let intervalId = null;
        let timeoutId = null;
        let speed = 150;
        let holdTicks = 0;
        
        const stop = () => {
            if (timeoutId) clearTimeout(timeoutId);
            if (intervalId) clearInterval(intervalId);
            intervalId = null;
            timeoutId = null;
            speed = 150;
            holdTicks = 0;
        };

        const tick = (input, dir) => {
            holdTicks += 1;
            const accel = Math.min(256, Math.pow(1.15, holdTicks));
            const scale = Math.max(1, Math.floor(accel));
            adjustNumberInput(input, dir, scale);
            speed = Math.max(12, speed * 0.9); // Accelerate
            if (intervalId) clearInterval(intervalId);
            intervalId = setInterval(() => tick(input, dir), speed);
        };

        const start = () => {
            const dir = parseInt(btn.getAttribute("data-dir"), 10) || 0;
            const input = btn.closest(".number-wrap")?.querySelector('input[type="number"]');
            if (input && !input.disabled) {
                input.focus();
                holdTicks = 0;
                adjustNumberInput(input, dir, 1); // Immediate change
                timeoutId = setTimeout(() => {
                    intervalId = setInterval(() => tick(input, dir), speed);
                }, 400); // Initial delay before repeating
            }
        };

        btn.addEventListener("mousedown", (e) => {
            if(e.button !== 0) return; // Only left click
            start();
        });
        btn.addEventListener("mouseup", stop);
        btn.addEventListener("mouseleave", stop);
    });
    updateInputHold();
}

setupNumberControls();
updateSailControlUi();
syncDiffractionDivergence();
if (emissivityInput) setNumberInputValue(emissivityInput, emissivity, true);
if (transmissionInput) setNumberInputValue(transmissionInput, atmTransmissionZenith, true);
if (beamQualityInput) setNumberInputValue(beamQualityInput, beamQuality, true);
if (spotFloorInput) setNumberInputValue(spotFloorInput, wFloor, true);
if (tempLimitInput) setNumberInputValue(tempLimitInput, tempLimitK, true);
if (irradianceLimitInput) setNumberInputValue(irradianceLimitInput, maxIrradianceLimit, true);
if (absorptanceInput) setNumberInputValue(absorptanceInput, absorptance, true);
if (diffractionToggle) diffractionToggle.checked = useDiffractionBeam;
if (radiationToggle) radiationToggle.checked = useRadiationCoupling;
if (absorptanceAutoToggle) absorptanceAutoToggle.checked = absorptanceFromReflectance;
if (irradianceAutoToggle) irradianceAutoToggle.checked = autoIrradianceLimit;
updateAbsorptanceUi();
updateIrradianceUi();
formatAllNumberInputs();

if (absorptanceAutoToggle) {
    absorptanceAutoToggle.addEventListener("change", updateAbsorptanceUi);
}
if (irradianceAutoToggle) {
    irradianceAutoToggle.addEventListener("change", updateIrradianceUi);
}
if (diffractionToggle) {
    diffractionToggle.addEventListener("change", () => {
        applyDiffractionToggle(diffractionToggle.checked);
    });
}
if (radiationToggle) {
    radiationToggle.addEventListener("change", () => {
        applyRadiationToggle(radiationToggle.checked);
    });
}

if (escapeToggleBtn) {
    escapeToggleBtn.addEventListener("click", () => {
        stopOnEscape = !stopOnEscape;
        if (!stopOnEscape && statusText === "ESCAPE") {
            simPaused = false;
            statusText = "OK";
        }
        updateEscapeButton();
    });
    updateEscapeButton();
}

if (missionXerionyxBtn) {
    missionXerionyxBtn.addEventListener("click", () => {
        applyMissionPreset("atmosphere");
    });
}

if (missionStarshotBtn) {
    missionStarshotBtn.addEventListener("click", () => {
        applyMissionPreset("starshot");
    });
}

updateMissionButton();

function showControlTooltip(target) {

    if (!controlTooltip || !target) return;

    const tip = target.getAttribute("data-tip");

    if (!tip) return;

    controlTooltip.textContent = tip;

    controlTooltip.classList.add("is-visible");

    controlTooltip.setAttribute("aria-hidden", "false");

    requestAnimationFrame(() => {

        const rect = target.getBoundingClientRect();

        const tipRect = controlTooltip.getBoundingClientRect();

        const margin = 8;

        

        let left = rect.left + rect.width / 2 - tipRect.width / 2;

        left = Math.max(margin, Math.min(left, window.innerWidth - tipRect.width - margin));

        

        let top = rect.top - tipRect.height - margin;

        if (top < margin) {

            top = rect.bottom + margin;

            if (top + tipRect.height > window.innerHeight - margin) {

                top = window.innerHeight - tipRect.height - margin;

            }

        }

        controlTooltip.style.left = `${left}px`;

        controlTooltip.style.top = `${top}px`;

    });

}

let tooltipPinnedTarget = null;

function hideControlTooltip() {
    if (!controlTooltip) return;
    controlTooltip.classList.remove("is-visible");
    controlTooltip.setAttribute("aria-hidden", "true");
    tooltipPinnedTarget = null;
}

document.querySelectorAll(".control-tip[data-tip]").forEach((el) => {
    el.addEventListener("mouseenter", () => showControlTooltip(el));
    el.addEventListener("mouseleave", hideControlTooltip);
    el.addEventListener("focus", () => showControlTooltip(el));
    el.addEventListener("blur", hideControlTooltip);
});

document.querySelectorAll(".telemetry-row[data-tip]").forEach((el) => {
    el.addEventListener("click", (event) => {
        if (!document.body.classList.contains('is-mobile')) return;
        event.stopPropagation();
        if (tooltipPinnedTarget === el) {
            hideControlTooltip();
        } else {
            tooltipPinnedTarget = el;
            showControlTooltip(el);
        }
    });
});

document.addEventListener("click", (event) => {
    if (!tooltipPinnedTarget) return;
    if (event.target.closest(".telemetry-row[data-tip]")) return;
    hideControlTooltip();
});
document.addEventListener("scroll", hideControlTooltip, { passive: true, capture: true });

const selectDropdowns = new Map();
const dropdownRegistry = [];

function closeAllDropdowns() {
    dropdownRegistry.forEach((dropdown) => dropdown.shell.classList.remove('open'));
}

document.addEventListener('click', (event) => {
    if (!event.target.closest('.color-map-dropdown')) {
        closeAllDropdowns();
    }
});

document.addEventListener('keydown', (event) => {
    if (event.key === 'Escape') {
        closeAllDropdowns();
    }
});

function syncSelectDropdown(selectEl) {
    const dropdown = selectDropdowns.get(selectEl);
    if (!dropdown) return;
    const selected = selectEl.options[selectEl.selectedIndex];
    if (selected) {
        dropdown.toggleLabel.textContent = selected.textContent;
    }
    dropdown.optionsScroll.querySelectorAll('.color-map-option').forEach((btn) => {
        btn.classList.toggle('active', btn.dataset.value === selectEl.value);
    });
}

function rebuildSelectDropdown(selectEl) {
    const dropdown = selectDropdowns.get(selectEl);
    if (!dropdown) return;
    dropdown.optionsScroll.innerHTML = '';
    Array.from(selectEl.options).forEach((opt) => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'color-map-option';
        btn.dataset.value = opt.value;
        btn.textContent = opt.textContent;
        btn.addEventListener('click', () => {
            if (selectEl.value !== opt.value) {
                selectEl.value = opt.value;
                selectEl.dispatchEvent(new Event('change', { bubbles: true }));
            }
            closeAllDropdowns();
        });
        dropdown.optionsScroll.appendChild(btn);
    });
    syncSelectDropdown(selectEl);
}

function initSelectDropdown(selectEl) {
    if (!selectEl || selectDropdowns.has(selectEl)) return selectDropdowns.get(selectEl);

    const shell = document.createElement('div');
    shell.className = 'color-map-dropdown control-dropdown';

    const toggle = document.createElement('button');
    toggle.type = 'button';
    toggle.className = 'color-map-toggle';
    const toggleLabel = document.createElement('span');
    toggleLabel.textContent = 'Select';
    const chevron = document.createElement('span');
    chevron.className = 'chevron';
    chevron.innerHTML = `
        <svg viewBox="0 0 16 16" width="16" height="16" aria-hidden="true" focusable="false">
            <path d="M3.5 6.5 8 11l4.5-4.5" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
    `;
    toggle.appendChild(toggleLabel);
    toggle.appendChild(chevron);

    const options = document.createElement('div');
    options.className = 'color-map-options';
    const optionsScroll = document.createElement('div');
    optionsScroll.className = 'color-map-options-scroll';
    options.appendChild(optionsScroll);

    toggle.addEventListener('click', (event) => {
        event.stopPropagation();
        const isOpen = shell.classList.contains('open');
        closeAllDropdowns();
        if (!isOpen) {
            shell.classList.add('open');
        }
    });

    toggle.addEventListener('wheel', (event) => {
        event.preventDefault();
        const direction = event.deltaY > 0 ? 1 : -1;
        const options = selectEl.options;
        if (!options.length) return;
        
        let newIndex = selectEl.selectedIndex + direction;
        if (newIndex < 0) newIndex = 0;
        if (newIndex >= options.length) newIndex = options.length - 1;
        
        if (newIndex !== selectEl.selectedIndex) {
            selectEl.selectedIndex = newIndex;
            selectEl.dispatchEvent(new Event('change', { bubbles: true }));
        }
    }, { passive: false });

    shell.appendChild(toggle);
    shell.appendChild(options);

    selectEl.classList.add('select-hidden');
    selectEl.insertAdjacentElement('afterend', shell);

    const dropdown = { shell, options, optionsScroll, toggleLabel };
    selectDropdowns.set(selectEl, dropdown);
    dropdownRegistry.push(dropdown);

    rebuildSelectDropdown(selectEl);

    selectEl.addEventListener('change', () => {
        syncSelectDropdown(selectEl);
    });

    return dropdown;
}

const couplingDropdown = initSelectDropdown(couplingModeSelect);
if (couplingDropdown) {
    couplingDropdown.shell.classList.add('open-up');
}
couplingModeSelect.addEventListener("change", () => {
    updateCouplingUi(couplingModeSelect.value);
});
updateCouplingUi(couplingModeSelect.value || "manual");

const plotFields = {
    time: { label: "Time (s)", get: (s) => s.time, clampMin: 0 },
    altitude: { label: "Altitude (m)", get: (s) => s.altitude, clampMin: 0 },
    range: { label: "LOS range (m)", get: (s) => s.range, clampMin: 0 },
    velocity: { label: "Velocity (m/s)", get: (s) => s.velocity },
    vOverC: { label: "v/c (unitless)", get: (s) => s.vOverC },
    lambdaSail: { label: "_sail (nm)", get: (s) => s.lambdaSailNm, clampMin: 0 },
    accel: { label: "Accel (m/s^2)", get: (s) => s.accel },
    pEmit: { label: "P_emit (W)", get: (s) => s.pEmit, clampMin: 0 },
    pHit: { label: "P_hit (W)", get: (s) => s.pHit, clampMin: 0 },
    pAbs: { label: "P_abs (W)", get: (s) => s.pAbs, clampMin: 0 },
    irradiance: { label: "I_avg (W/m2)", get: (s) => s.irradiance, clampMin: 0 },
    irradiance0: { label: "I_peak (W/m2)", get: (s) => s.irradiance0, clampMin: 0 },
    wEff: { label: "Beam radius (m)", get: (s) => s.wEff, clampMin: 0 },
    angularSize: { label: "Angular size (mrad)", get: (s) => s.angularSize, clampMin: 0 },
    pointingTol: { label: "Pointing tol (mrad)", get: (s) => s.pointingTol, clampMin: 0 },
    beamRatio: { label: "Beam/sail ratio", get: (s) => s.beamRatio, clampMin: 0 },
    fHit: { label: "Capture f_hit", get: (s) => s.fHit, clampMin: 0 },
    fLaser: { label: "F_laser (N)", get: (s) => s.fLaser, clampMin: 0 },
    fDrag: { label: "F_drag (N)", get: (s) => s.fDrag },
    dynQ: { label: "Dyn pressure (Pa)", get: (s) => s.dynQ, clampMin: 0 },
    mach: { label: "Mach", get: (s) => s.mach, clampMin: 0 },
    reynolds: { label: "Re (unitless)", get: (s) => s.reynolds, clampMin: 0 },
    tStag: { label: "T_stag (K)", get: (s) => s.tStag, clampMin: 0 },
    heatFlux: { label: "Heat flux (W/m2)", get: (s) => s.heatFlux, clampMin: 0 },
    rho: { label: "Density (kg/m3)", get: (s) => s.rho, clampMin: 0 },
    tempK: { label: "Temp (K)", get: (s) => s.tempK, clampMin: 0 },
    vEff: { label: "V_eff (m/s)", get: (s) => s.vEff, clampMin: 0 },
    isp: { label: "Isp (s)", get: (s) => s.isp, clampMin: 0 },
    impulse: { label: "Impulse (N*s)", get: (s) => s.impulse, clampMin: 0 },
    energyHit: { label: "E_hit (J)", get: (s) => s.energyHit, clampMin: 0 },
    energyAbs: { label: "E_abs (J)", get: (s) => s.energyAbs, clampMin: 0 },
    epsilon: { label: "Escape eps (J/kg)", get: (s) => s.epsilon },
    costUSD: { label: "Cost (USD)", get: (s) => s.costUSD, clampMin: 0 }
};

const plotFieldOrder = [
    "time",
    "altitude",
    "range",
    "velocity",
    "vOverC",
    "lambdaSail",
    "accel",
    "pEmit",
    "pHit",
    "pAbs",
    "irradiance",
    "irradiance0",
    "wEff",
    "angularSize",
    "pointingTol",
    "beamRatio",
    "fHit",
    "fLaser",
    "fDrag",
    "dynQ",
    "mach",
    "reynolds",
    "tStag",
    "heatFlux",
    "rho",
    "tempK",
    "vEff",
    "isp",
    "impulse",
    "energyHit",
    "energyAbs",
    "epsilon",
    "costUSD"
];

function initPlotControls() {
    plotFieldOrder.forEach((key) => {
        const field = plotFields[key];
        if (!field) return;
        const optX = document.createElement("option");
        optX.value = key;
        optX.textContent = field.label;
        const optY = optX.cloneNode(true);
        plotXSelect.appendChild(optX);
        plotYSelect.appendChild(optY);
    });
    plotXSelect.value = "time";
    plotYSelect.value = "altitude";
    plotXSelect.addEventListener("change", drawPlot);
    plotYSelect.addEventListener("change", drawPlot);
    const plotXDropdown = initSelectDropdown(plotXSelect);
    if (plotXDropdown) {
        plotXDropdown.shell.classList.add('plot-dropdown');
    }
    const plotYDropdown = initSelectDropdown(plotYSelect);
    if (plotYDropdown) {
        plotYDropdown.shell.classList.add('plot-dropdown');
    }
}

function resizePlotCanvas() {
    if (!plotCanvas) return;

    syncPlotHeight();
    
    const isMobile = document.body.classList.contains('is-mobile');
    const rect = plotCanvas.getBoundingClientRect();
    let cssW = Math.round(rect.width);
    let cssH = Math.round(rect.height);
    if (isMobile && plotIsland) {
        const islandRect = plotIsland.getBoundingClientRect();
        const titleEl = plotIsland.querySelector('.plot-title');
        const controlsEl = plotIsland.querySelector('.plot-controls');
        const titleH = titleEl ? titleEl.getBoundingClientRect().height : 0;
        const controlsH = controlsEl ? controlsEl.getBoundingClientRect().height : 0;
        const style = getComputedStyle(plotIsland);
        const padY = (parseFloat(style.paddingTop) || 0) + (parseFloat(style.paddingBottom) || 0);
        const padX = (parseFloat(style.paddingLeft) || 0) + (parseFloat(style.paddingRight) || 0);
        const gap = 8 * 2;
        cssW = Math.max(0, Math.round(islandRect.width - padX));
        cssH = Math.max(0, Math.round(islandRect.height - padY - titleH - controlsH - gap));
    }
    
    // Fallback if rect is 0 or suspiciously small
    if (cssW < 10) cssW = plotCanvas.offsetWidth;
    if (cssH < 10) cssH = plotCanvas.offsetHeight;
    
    // Deeper fallback for mobile overlays
    if (cssW < 10 && plotCanvas.parentElement) {
        const parentRect = plotCanvas.parentElement.getBoundingClientRect();
        cssW = Math.round(parentRect.width) - 40; 
        cssH = Math.round(parentRect.height) - 120; 
    }
    
    // Ensure absolute minimums
    cssW = Math.max(isMobile ? 250 : 100, cssW);
    cssH = Math.max(isMobile ? 240 : 100, cssH);

    plotCanvas.style.width = cssW + "px";
    plotCanvas.style.height = cssH + "px";
    plotDpr = window.devicePixelRatio || 1;
    plotCanvas.width = Math.max(1, Math.floor(cssW * plotDpr));
    plotCanvas.height = Math.max(1, Math.floor(cssH * plotDpr));
    plotCtx.setTransform(plotDpr, 0, 0, plotDpr, 0, 0);
    drawPlot();
}

function syncPlotHeight() {
    if (!plotIsland || !plotCanvas) return;
    if (document.body.classList.contains('is-mobile')) return;
    const waveIsland = document.getElementById('wavefront-island');
    if (!waveIsland) return;
    const plotRect = plotIsland.getBoundingClientRect();
    const waveRect = waveIsland.getBoundingClientRect();
    if (!Number.isFinite(plotRect.top) || !Number.isFinite(waveRect.top)) return;
    const gap = 16;
    const maxHeight = Math.min(520, waveRect.top - gap - plotRect.top);
    const height = Math.max(320, Math.floor(maxHeight));
    plotIsland.style.height = `${height}px`;
}

function syncTelemetryHeight() {
    const telemetryIsland = document.getElementById('telemetry-island');
    const couplingIsland = document.getElementById('coupling-island');
    if (!telemetryIsland || !couplingIsland) return;
    if (document.body.classList.contains('is-mobile')) {
        telemetryIsland.style.maxHeight = '';
        return;
    }
    const teleRect = telemetryIsland.getBoundingClientRect();
    const couplingRect = couplingIsland.getBoundingClientRect();
    if (!Number.isFinite(teleRect.top) || !Number.isFinite(couplingRect.top)) return;
    const gap = 16;
    const available = couplingRect.top - gap - teleRect.top;
    const telemetryContent = telemetryIsland.querySelector('.telemetry');
    const previousMax = telemetryIsland.style.maxHeight;
    telemetryIsland.style.maxHeight = '';
    const needed = telemetryIsland.scrollHeight;
    telemetryIsland.style.maxHeight = previousMax;
    if (available >= needed) {
        telemetryIsland.style.maxHeight = '';
        if (telemetryContent) telemetryContent.classList.remove('is-scroll');
        return;
    }
    const maxHeight = Math.max(200, Math.floor(available));
    telemetryIsland.style.maxHeight = `${maxHeight}px`;
    if (telemetryContent) telemetryContent.classList.add('is-scroll');
}

function formatPlotValue(value) {
    if (!isFinite(value)) return "0";
    const abs = Math.abs(value);
    if (abs === 0) return "0";
    if (abs < 0.001 || abs >= 100000) return value.toExponential(2);
    if (abs >= 1000) return value.toFixed(0);
    if (abs >= 100) return value.toFixed(1);
    if (abs >= 10) return value.toFixed(2);
    return value.toFixed(3);
}

function getPlotPoints() {
    const xField = plotFields[plotXSelect.value];
    const yField = plotFields[plotYSelect.value];
    if (!xField || !yField) return { points: [], xField, yField };
    const points = [];
    for (let i = 0; i < plotSamples.length; i++) {
        const sample = plotSamples[i];
        const xVal = xField.get(sample);
        const yVal = yField.get(sample);
        if (!isFinite(xVal) || !isFinite(yVal)) continue;
        points.push({ x: xVal, y: yVal });
    }
    return { points, xField, yField };
}

function resamplePoints(points, count) {
    if (points.length === 0) return [];
    if (points.length === 1) {
        return Array.from({ length: count }, () => ({ x: points[0].x, y: points[0].y }));
    }
    const maxIndex = points.length - 1;
    const samples = [];
    for (let i = 0; i < count; i++) {
        const t = count === 1 ? 0 : i / (count - 1);
        const idx = t * maxIndex;
        const idx0 = Math.floor(idx);
        const idx1 = Math.min(idx0 + 1, maxIndex);
        const frac = idx - idx0;
        const p0 = points[idx0];
        const p1 = points[idx1];
        samples.push({
            x: p0.x + (p1.x - p0.x) * frac,
            y: p0.y + (p1.y - p0.y) * frac
        });
    }
    return samples;
}

function downloadPlotCsv() {
    const { points, xField, yField } = getPlotPoints();
    if (!points.length || !xField || !yField) {
        alert("No plot data yet. Start simulation to get data.");
        return;
    }
    const samples = resamplePoints(points, CSV_SAMPLE_COUNT);
    const header = `${xField.label},${yField.label}`;
    const lines = [header];
    for (let i = 0; i < samples.length; i++) {
        const row = samples[i];
        lines.push(`${row.x},${row.y}`);
    }
    const blob = new Blob([lines.join("\n")], { type: "text/csv" });
    const url = URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.href = url;
    link.download = `plot_${plotXSelect.value}_vs_${plotYSelect.value}.csv`;
    document.body.appendChild(link);
    link.click();
    link.remove();
    URL.revokeObjectURL(url);
}

function hidePlotTooltip() {
    plotTooltip.style.display = "none";
}

function updatePlotTooltip(nearest, xField, yField, canvasRect) {
    if (!nearest) {
        hidePlotTooltip();
        return;
    }

    plotTooltip.innerHTML = `<div>X (${xField.label}): ${formatPlotValue(nearest.x)}</div>` +
        `<div>Y (${yField.label}): ${formatPlotValue(nearest.y)}</div>`;
    plotTooltip.style.display = "block";

    const islandRect = plotIsland.getBoundingClientRect();
    let boxX = (canvasRect.left - islandRect.left) + plotHover.x + 12;
    let boxY = (canvasRect.top - islandRect.top) + plotHover.y + 12;
    const boxW = plotTooltip.offsetWidth;
    const boxH = plotTooltip.offsetHeight;

    if (boxX + boxW > islandRect.width - 4) boxX = islandRect.width - 4 - boxW;
    if (boxY + boxH > islandRect.height - 4) boxY = (canvasRect.top - islandRect.top) + plotHover.y - boxH - 12;
    if (boxX < 4) boxX = 4;
    if (boxY < 4) boxY = 4;

    plotTooltip.style.left = Math.round(boxX) + "px";
    plotTooltip.style.top = Math.round(boxY) + "px";
}

function pushPlotSample() {
    if (!lastTelemetry) return;
    const t = simElapsed;
    if (t - lastPlotSampleTime < PLOT_SAMPLE_DT) return;
    lastPlotSampleTime = t;
    plotSamples.push({ ...lastTelemetry, time: t });
    if (PLOT_MAX_SAMPLES > 0 && plotSamples.length > PLOT_MAX_SAMPLES) {
        plotSamples.splice(0, plotSamples.length - PLOT_MAX_SAMPLES);
    }
}

function drawPlot() {
    const w = plotCanvas.width / plotDpr;
    const h = plotCanvas.height / plotDpr;
    plotCtx.clearRect(0, 0, w, h);

    const showStartMessage = !simStarted;

    const xField = plotFields[plotXSelect.value];
    const yField = plotFields[plotYSelect.value];
    if (!xField || !yField) return;

    let xMin = Infinity;
    let xMax = -Infinity;
    let yMin = Infinity;
    let yMax = -Infinity;

    const maxRenderPoints = 2000;
    const stride = Math.ceil(plotSamples.length / maxRenderPoints) || 1;

    for (let i = 0; i < plotSamples.length; i += stride) {
        const sample = plotSamples[i];
        const xVal = xField.get(sample);
        const yVal = yField.get(sample);
        if (!isFinite(xVal) || !isFinite(yVal)) continue;
        if (xVal < xMin) xMin = xVal;
        if (xVal > xMax) xMax = xVal;
        if (yVal < yMin) yMin = yVal;
        if (yVal > yMax) yMax = yVal;
    }

    // Always include the latest sample if not already included for min/max
    if (plotSamples.length > 0 && (plotSamples.length - 1) % stride !== 0) {
        const sample = plotSamples[plotSamples.length - 1];
        const xVal = xField.get(sample);
        const yVal = yField.get(sample);
        if (isFinite(xVal) && isFinite(yVal)) {
            if (xVal < xMin) xMin = xVal;
            if (xVal > xMax) xMax = xVal;
            if (yVal < yMin) yMin = yVal;
            if (yVal > yMax) yMax = yVal;
        }
    }

    if (xMin === Infinity) {
        xMin = xField.clampMin != null ? xField.clampMin : 0;
        xMax = xMin + 1;
        yMin = yField.clampMin != null ? yField.clampMin : 0;
        yMax = yMin + 1;
    }

    if (xMin === xMax) {
        if (xField.clampMin != null) {
            xMax += 1;
        } else {
            xMin -= 1;
            xMax += 1;
        }
    }
    if (yMin === yMax) {
        if (yField.clampMin != null) {
            yMax += 1;
        } else {
            yMin -= 1;
            yMax += 1;
        }
    }

    const xPadFrac = 0;
    const yPadTopFrac = 0.02;
    const xPad = (xMax - xMin) * xPadFrac;
    const yPadTop = (yMax - yMin) * yPadTopFrac;
    xMin -= xPad;
    xMax += xPad;
    yMax += yPadTop;

    if (xField.clampMin != null) {
        xMin = Math.max(xMin, xField.clampMin);
    }
    if (yField.clampMin != null) {
        yMin = Math.max(yMin, yField.clampMin);
    }

    if (xMin === xMax) {
        if (xField.clampMin != null) {
            xMax += 1;
        } else {
            xMin -= 1;
            xMax += 1;
        }
    }
    if (yMin === yMax) {
        if (yField.clampMin != null) {
            yMax += 1;
        } else {
            yMin -= 1;
            yMax += 1;
        }
    }

    const isMobile = document.body.classList.contains('is-mobile');
    const ticks = 4;
    plotCtx.font = isMobile ? "12px monospace" : "13px monospace";
    const baseLeft = isMobile ? 45 : 64;
    let yLabelMax = 0;
    for (let i = 0; i <= ticks; i++) {
        const yVal = yMax - ((yMax - yMin) * i) / ticks;
        const label = formatPlotValue(yVal);
        const width = plotCtx.measureText(label).width;
        if (width > yLabelMax) yLabelMax = width;
    }
    const leftMargin = Math.max(baseLeft, Math.ceil(yLabelMax + 14));
    const margin = isMobile 
        ? { left: leftMargin, right: 10, top: 10, bottom: 25 } 
        : { left: Math.max(64, Math.ceil(yLabelMax + 18)), right: 28, top: 16, bottom: 28 };
        
    const plotW = Math.max(1, w - margin.left - margin.right);
    const plotH = Math.max(1, h - margin.top - margin.bottom);

    const xScale = plotW / (xMax - xMin);
    const yScale = plotH / (yMax - yMin);
    const xToPx = (v) => margin.left + (v - xMin) * xScale;
    const yToPx = (v) => margin.top + plotH - (v - yMin) * yScale;

    plotCtx.strokeStyle = "rgba(255,255,255,0.08)";
    plotCtx.lineWidth = 1;
    for (let i = 1; i < ticks; i++) {
        const gx = margin.left + (plotW * i) / ticks;
        const gy = margin.top + (plotH * i) / ticks;
        plotCtx.beginPath();
        plotCtx.moveTo(gx, margin.top);
        plotCtx.lineTo(gx, margin.top + plotH);
        plotCtx.stroke();
        plotCtx.beginPath();
        plotCtx.moveTo(margin.left, gy);
        plotCtx.lineTo(margin.left + plotW, gy);
        plotCtx.stroke();
    }

    plotCtx.strokeStyle = "#555";
    plotCtx.lineWidth = 1;
    plotCtx.beginPath();
    plotCtx.moveTo(margin.left, margin.top);
    plotCtx.lineTo(margin.left, margin.top + plotH);
    plotCtx.moveTo(margin.left, margin.top + plotH);
    plotCtx.lineTo(margin.left + plotW, margin.top + plotH);
    plotCtx.stroke();

    plotCtx.fillStyle = "#999";
    for (let i = 0; i <= ticks; i++) {
        const xVal = xMin + ((xMax - xMin) * i) / ticks;
        const yVal = yMax - ((yMax - yMin) * i) / ticks;
        const xPx = margin.left + (plotW * i) / ticks;
        const yPx = margin.top + (plotH * i) / ticks;
        const xText = formatPlotValue(xVal);
        const xTextWidth = plotCtx.measureText(xText).width;
        const xTextX = Math.min(xPx - xTextWidth / 2, w - 4 - xTextWidth);
        
        plotCtx.textAlign = "left";
        plotCtx.fillText(xText, xTextX, margin.top + plotH + 16);
        
        plotCtx.textAlign = "right";
        plotCtx.fillText(formatPlotValue(yVal), margin.left - 8, yPx + 3);
    }
    plotCtx.textAlign = "left";

    plotCtx.save();
    plotCtx.beginPath();
    plotCtx.rect(margin.left, margin.top, plotW, plotH);
    plotCtx.clip();

    if (plotSamples.length > 0) {
        plotCtx.strokeStyle = "#00ffcc";
        plotCtx.lineWidth = 1.5;
        plotCtx.lineJoin = "round";
        plotCtx.lineCap = "round";
        plotCtx.beginPath();
        
        let first = true;
        let nearest = null;
        let bestDx = Infinity;
        const hoverXVal = xMin + (plotHover.x - margin.left) / xScale;

        const processSample = (sample) => {
            const xVal = xField.get(sample);
            const yVal = yField.get(sample);
            if (!isFinite(xVal) || !isFinite(yVal)) return;
            
            const px = xToPx(xVal);
            const py = yToPx(yVal);
            if (first) {
                plotCtx.moveTo(px, py);
                first = false;
            } else {
                plotCtx.lineTo(px, py);
            }
            
            if (plotHover.active) {
                const dx = Math.abs(xVal - hoverXVal);
                if (dx < bestDx) {
                    bestDx = dx;
                    nearest = { x: xVal, y: yVal };
                }
            }
        };

        plotCtx.save();
        plotCtx.beginPath();
        plotCtx.rect(margin.left, margin.top, plotW, plotH);
        plotCtx.clip();

        for (let i = 0; i < plotSamples.length; i += stride) {
            processSample(plotSamples[i]);
        }
        if (plotSamples.length > 0 && (plotSamples.length - 1) % stride !== 0) {
            processSample(plotSamples[plotSamples.length - 1]);
        }
        
        if (!first) plotCtx.stroke();

        if (plotHover.active && nearest) {
            const inside = plotHover.x >= margin.left && plotHover.x <= margin.left + plotW
                && plotHover.y >= margin.top && plotHover.y <= margin.top + plotH;
            if (inside) {
                const px = xToPx(nearest.x);
                const py = yToPx(nearest.y);
                plotCtx.fillStyle = "#00ffcc";
                plotCtx.beginPath();
                plotCtx.arc(px, py, 3, 0, Math.PI * 2);
                plotCtx.fill();
                updatePlotTooltip(nearest, xField, yField, plotCanvas.getBoundingClientRect());
            } else {
                hidePlotTooltip();
            }
        } else {
            hidePlotTooltip();
        }
        plotCtx.restore();
    } else {
        hidePlotTooltip();
    }

    plotCtx.restore();

    // Remove any top/right border line without clipping the plotted data.
    plotCtx.clearRect(margin.left + 1, margin.top - 1, plotW - 1, 2);
    plotCtx.clearRect(margin.left + plotW - 1, margin.top, 2, plotH - 1);

    if (showStartMessage) {
        const msg = "Start simulation to get data";
        plotCtx.font = "13px monospace";
        const textW = plotCtx.measureText(msg).width;
        const padding = 10;
        const boxW = textW + padding * 2;
        const boxH = 28;
        const boxX = (w - boxW) / 2;
        const boxY = (h - boxH) / 2;
        plotCtx.fillStyle = "rgba(12,12,12,0.9)";
        plotCtx.strokeStyle = "#333";
        plotCtx.lineWidth = 1;
        plotCtx.beginPath();
        plotCtx.rect(boxX, boxY, boxW, boxH);
        plotCtx.fill();
        plotCtx.stroke();
        plotCtx.fillStyle = "#cfcfcf";
        plotCtx.fillText(msg, boxX + padding, boxY + 19);
    }
}

initPlotControls();
resizePlotCanvas();
syncTelemetryHeight();
window.addEventListener('resize', resizePlotCanvas);
plotDownloadBtn.addEventListener("click", downloadPlotCsv);
plotCanvas.addEventListener("mousemove", (event) => {
    const rect = plotCanvas.getBoundingClientRect();
    plotHover.x = event.clientX - rect.left;
    plotHover.y = event.clientY - rect.top;
    plotHover.active = true;
    drawPlot();
});
plotCanvas.addEventListener("mouseleave", () => {
    plotHover.active = false;
    drawPlot();
});

const atmLayers = [
    { h: 0,     L: -0.0065, T: 288.15, P: 101325 },
    { h: 11000, L: 0.0 },
    { h: 20000, L: 0.001 },
    { h: 32000, L: 0.0028 },
    { h: 47000, L: 0.0 },
    { h: 51000, L: -0.0028 },
    { h: 71000, L: -0.002 },
    { h: 84852, L: 0.0 }
];

// Pre-compute base T/P for each layer to match 1976 US Standard Atmosphere
(function initAtmosphere() {
    for (let i = 1; i < atmLayers.length; i++) {
        const prev = atmLayers[i - 1];
        const layer = atmLayers[i];
        const dh = layer.h - prev.h;
        const Tbase = prev.T + prev.L * dh;
        let Pbase;
        if (prev.L === 0) {
            Pbase = prev.P * Math.exp(-G0 / (R_SPEC * prev.T) * dh);
        } else {
            Pbase = prev.P * Math.pow(prev.T / Tbase, G0 / (prev.L * R_SPEC));
        }
        layer.T = Tbase;
        layer.P = Pbase;
    }
})();
tempK = atmosphereState(H0).T;
applySailDiameter(parseFloat(sailDiameterInput.value));
applyBeamRadiusOverride(parseFloat(beamRadiusInput.value));
applyMass(parseFloat(massInput.value));
if (cmInput) applyCouplingCm(parseFloat(cmInput.value));
if (divInput) applyDivergence(parseFloat(divInput.value));
if (reflectanceInput) applyReflectance(parseFloat(reflectanceInput.value));
applyStartAltitude(parseFloat(altitudeSlider.value));

function formatClock(seconds) {
    const total = Math.max(0, Math.floor(seconds));
    const hrs = Math.floor(total / 3600);
    const mins = Math.floor((total % 3600) / 60);
    const secs = total % 60;
    return `${String(hrs).padStart(2, '0')}:${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
}

function dopplerFactor(beta) {
    const clamped = Math.max(-0.999999, Math.min(0.999999, beta));
    return Math.sqrt((1 + clamped) / (1 - clamped));
}

function observedLambdaNm(velocity) {
    const beta = velocity / C;
    const factor = dopplerFactor(beta);
    return (LAMBDA * factor) * 1e9;
}

function getAbsorbedPowerMW() {
    if (!lastTelemetry || !Number.isFinite(lastTelemetry.pAbs)) return 0;
    return Math.max(0, lastTelemetry.pAbs / 1e6);
}

function getAblationTargetCount(pAbsMW) {
    if (!Number.isFinite(pAbsMW) || pAbsMW <= ABLATION_PABS_OFF_MW) return 0;
    if (pAbsMW >= ABLATION_PABS_ON_MW) return ABLATION_PARTICLE_MAX;
    const t = (pAbsMW - ABLATION_PABS_OFF_MW) / (ABLATION_PABS_ON_MW - ABLATION_PABS_OFF_MW);
    const scaled = Math.round(ABLATION_PARTICLE_MAX * t);
    return Math.min(ABLATION_PARTICLE_MAX, Math.max(0, scaled));
}

function updateAndDrawAblationParticles(centerY, sailHalf) {
    const now = performance.now();
    const rawDt = (now - ablationLastStamp) / 1000;
    ablationLastStamp = now;
    const dt = isPaused() ? 0 : Math.min(0.05, Math.max(0, rawDt));

    if (activeMissionKey !== "atmosphere") {
        ablationParticles.length = 0;
        ablationSpawnAccumulator = 0;
        return;
    }

    const pAbsMW = getAbsorbedPowerMW();
    const targetCount = getAblationTargetCount(pAbsMW);

    if (targetCount === 0) {
        ablationParticles.length = 0;
        ablationSpawnAccumulator = 0;
        return;
    }

    const powerT = Math.max(0, Math.min(1, (pAbsMW - ABLATION_PABS_OFF_MW) / (ABLATION_PABS_ON_MW - ABLATION_PABS_OFF_MW)));
    const maxCount = Math.min(ABLATION_PARTICLE_MAX, targetCount);

    if (dt > 0) {
        const emitRate = maxCount / ABLATION_PARTICLE_LIFE;
        ablationSpawnAccumulator += emitRate * dt;
        const spawnCount = Math.min(maxCount - ablationParticles.length, Math.floor(ablationSpawnAccumulator));
        if (spawnCount > 0) {
            ablationSpawnAccumulator -= spawnCount;
            for (let i = 0; i < spawnCount; i++) {
                const x = (width / 2) + (Math.random() * 2 - 1) * sailHalf;
                const y = centerY + 1;
                const speedBase = 120 + (powerT * 320);
                const speed = speedBase * (0.6 + Math.random() * 0.6);
                const angle = (Math.PI / 2) + (Math.random() - 0.5) * ABLATION_PARTICLE_SPREAD;
                const life = ABLATION_PARTICLE_LIFE * (0.6 + Math.random() * 0.8);
                ablationParticles.push({
                    x,
                    y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    size: 1 + Math.random() * 1.6,
                    life,
                    lifeMax: life,
                    r: 255,
                    g: Math.round(150 + Math.random() * 70),
                    b: Math.round(40 + Math.random() * 30)
                });
            }
        }
        if (ablationParticles.length > maxCount) {
            ablationParticles.splice(0, ablationParticles.length - maxCount);
        }
    }

    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    for (let i = ablationParticles.length - 1; i >= 0; i--) {
        const p = ablationParticles[i];
        if (dt > 0) {
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            p.vy += 40 * dt;
            p.life -= dt;
        }
        if (p.life <= 0 || p.y > height + 20 || p.x < -20 || p.x > width + 20) {
            ablationParticles.splice(i, 1);
            continue;
        }
        const alpha = Math.max(0, Math.min(1, p.life / p.lifeMax));
        ctx.fillStyle = `rgba(${p.r}, ${p.g}, ${p.b}, ${alpha})`;
        ctx.fillRect(p.x, p.y, p.size, p.size);
    }
    ctx.restore();
}

function spawnExplosionParticles(originX, originY, color) {
    explosionParticles.length = 0;
    const rgb = color || { r: 255, g: 200, b: 120 };
    for (let i = 0; i < EXPLOSION_PARTICLE_COUNT; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = EXPLOSION_PARTICLE_SPEED * (0.4 + Math.random() * 0.8);
        const life = EXPLOSION_PARTICLE_LIFE * (0.6 + Math.random() * 0.8);
        explosionParticles.push({
            x: originX,
            y: originY,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life,
            lifeMax: life,
            size: 1.5 + Math.random() * 2.5,
            r: Math.min(255, Math.round(rgb.r + Math.random() * 40)),
            g: Math.min(255, Math.round(rgb.g + Math.random() * 40)),
            b: Math.min(255, Math.round(rgb.b + Math.random() * 30))
        });
    }
    explosionShock = 1;
    explosionLastStamp = performance.now();
}

function updateAndDrawExplosionParticles() {
    if (explosionParticles.length === 0 && explosionShock <= 0) return;
    const now = performance.now();
    const dt = Math.min(0.05, Math.max(0, (now - explosionLastStamp) / 1000));
    explosionLastStamp = now;

    if (explosionShock > 0) {
        const shockRadius = 20 + (1 - explosionShock) * 160;
        const shockAlpha = Math.max(0, Math.min(1, explosionShock));
        ctx.save();
        ctx.globalCompositeOperation = "lighter";
        ctx.strokeStyle = `rgba(255, 210, 140, ${0.6 * shockAlpha})`;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(explosionOrigin.x, explosionOrigin.y, shockRadius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.fillStyle = `rgba(255, 160, 80, ${0.12 * shockAlpha})`;
        ctx.beginPath();
        ctx.arc(explosionOrigin.x, explosionOrigin.y, shockRadius * 0.6, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
        explosionShock -= dt * 1.4;
    }

    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    for (let i = explosionParticles.length - 1; i >= 0; i--) {
        const p = explosionParticles[i];
        if (dt > 0) {
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            p.vy += 80 * dt;
            p.life -= dt;
        }
        if (p.life <= 0) {
            explosionParticles.splice(i, 1);
            continue;
        }
        const alpha = Math.max(0, Math.min(1, p.life / p.lifeMax));
        ctx.strokeStyle = `rgba(${p.r}, ${p.g}, ${p.b}, ${alpha})`;
        ctx.lineWidth = Math.max(1, p.size * 0.6);
        const dx = (p.vx * 0.02);
        const dy = (p.vy * 0.02);
        ctx.beginPath();
        ctx.moveTo(p.x, p.y);
        ctx.lineTo(p.x - dx, p.y - dy);
        ctx.stroke();
    }
    ctx.restore();
}

// Bessel approximations (Cephes-like) to support optional Airy mode
function besselJ0(x) {
    const ax = Math.abs(x);
    if (ax < 8.0) {
        const y = x * x;
        const num = 57568490574 + y * (-13362590354 + y * (651619640.7 + y * (-11214424.18 + y * (77392.33017 + y * (-184.9052456)))));
        const den = 57568490411 + y * (1029532985 + y * (9494680.718 + y * (59272.64853 + y * (267.8532712 + y))));
        return num / den;
    }
    const z = 8 / ax;
    const y = z * z;
    const xx = ax - 0.785398164;
    const ans = Math.sqrt(0.636619772 / ax) *
        (Math.cos(xx) * (1 - y * (0.1098628627 - y * (0.2734510407 - y * 0.2073370639)))
         - z * Math.sin(xx) * (0.1562499995 - y * (0.1430488765 - y * (0.0918956810 - y * 0.0137060048))));
    return ans;
}

function besselJ1(x) {
    const ax = Math.abs(x);
    if (ax < 8.0) {
        const y = x * x;
        const num = x * (72362614232 + y * (-7895059235 + y * (242396853.1 + y * (-2972611.439 + y * (15704.48260 + y * (-30.16036606))))));
        const den = 144725228442 + y * (2300535178 + y * (18583304.74 + y * (99447.43394 + y * (376.9991397 + y))));
        return num / den;
    }
    const z = 8 / ax;
    const y = z * z;
    const xx = ax - 2.356194491;
    const ans = Math.sqrt(0.636619772 / ax) *
        (Math.cos(xx) * (1 - y * (0.001098628627 - y * (0.000002585298 - y * 0.000001198924)))
         - z * Math.sin(xx) * (0.375 - y * (0.04166397064 - y * (0.00291297137 - y * 0.0001052485))));
    return x < 0 ? -ans : ans;
}

function atmosphereState(altitude) {
    const hClamped = Math.max(0, altitude);
    const top = atmLayers[atmLayers.length - 1];
    if (hClamped >= top.h) {
        const dh = hClamped - top.h;
        const H = R_SPEC * top.T / G0;
        const P = top.P * Math.exp(-dh / H);
        const T = top.T;
        const rho = P / (R_SPEC * T);
        return { T, P, rho };
    }
    let idx = 0;
    for (let i = 0; i < atmLayers.length - 1; i++) {
        if (hClamped >= atmLayers[i].h && hClamped < atmLayers[i + 1].h) {
            idx = i;
            break;
        }
    }
    const base = atmLayers[idx];
    const dh = hClamped - base.h;
    let T, P;
    if (base.L === 0) {
        T = base.T;
        P = base.P * Math.exp(-G0 / (R_SPEC * T) * dh);
    } else {
        T = base.T + base.L * dh;
        P = base.P * Math.pow(base.T / T, G0 / (base.L * R_SPEC));
    }
    const rho = P / (R_SPEC * T);
    return { T, P, rho };
}

function rhoAt(h_m) {
    return atmosphereState(h_m).rho;
}

function environmentTemp(rho, atmT) {
    const fSpace = 1 / (1 + rho / RHO_ENV);
    return T_SPACE + (atmT - T_SPACE) * (1 - fSpace);
}

function convectiveH(rho) {
    if (rho <= 0) return 0;
    return H_CONV0 * Math.pow(rho / RHO0, H_CONV_POW);
}

function tempLimitedIrradiance(maxTempK) {
    if (!Number.isFinite(maxTempK) || maxTempK <= 0) return Infinity;
    const tEnv = T_SPACE;
    const rad = Math.max(0, (Math.pow(maxTempK, 4) - Math.pow(tEnv, 4)));
    const denom = Math.max(absorptance, 1e-16);
    return (2 * emissivity * SIGMA * rad) / denom;
}

function airViscosity(T) {
    const t = Math.max(T, 1);
    const mu0 = 1.716e-5;
    const T0 = 273.15;
    const S = 110.4;
    return mu0 * Math.pow(t / T0, 1.5) * (T0 + S) / (t + S);
}

function gaussianSpot(zRange, aperture) {
    // Option A: Gaussian-equivalent matched to Airy first-zero energy (0.838 encircled)
    const r1 = 1.22 * LAMBDA * zRange / aperture;
    const w = 1.05 * r1; // 1/e^2 radius that matches Airy encircled energy
    const wEff = Math.max(w / Math.sqrt(Math.max(beamQuality, 1e-9)), wFloor);
    const fHit = 1 - Math.exp(-2 * sailRadius * sailRadius / (wEff * wEff));
    return { wEff, fHit: Math.min(1, Math.max(0, fHit)) };
}

function airySpot(zRange, aperture) {
    const r1 = 1.22 * LAMBDA * zRange / aperture;
    const x = Math.PI * aperture * sailRadius / (LAMBDA * zRange);
    const fHit = 1 - (besselJ0(x) ** 2 + besselJ1(x) ** 2);
    const wEff = Math.max(r1 / Math.sqrt(Math.max(beamQuality, 1e-9)), wFloor);
    return { wEff, fHit: Math.min(1, Math.max(0, fHit)) };
}

function beamAtRange(zRange, aperture) {
    if (USE_AIRY_MODEL) return airySpot(zRange, aperture);
    return gaussianSpot(zRange, aperture);
}

function wavelengthToRgb(wavelengthMeters) {
    let wlNm = wavelengthMeters * 1e9;
    if (!Number.isFinite(wlNm)) {
        return { r: 255, g: 50, b: 50 };
    }
    // Clamp to 380nm for anything shorter
    if (wlNm < 380) wlNm = 380;

    let r = 0;
    let g = 0;
    let b = 0;
    if (wlNm >= 380 && wlNm < 440) {
        r = -(wlNm - 440) / (440 - 380);
        g = 0;
        b = 1;
    } else if (wlNm >= 440 && wlNm < 490) {
        r = 0;
        g = (wlNm - 440) / (490 - 440);
        b = 1;
    } else if (wlNm >= 490 && wlNm < 510) {
        r = 0;
        g = 1;
        b = -(wlNm - 510) / (510 - 490);
    } else if (wlNm >= 510 && wlNm < 580) {
        r = (wlNm - 510) / (580 - 510);
        g = 1;
        b = 0;
    } else if (wlNm >= 580 && wlNm < 645) {
        r = 1;
        g = -(wlNm - 645) / (645 - 580);
        b = 0;
    } else if (wlNm >= 645 && wlNm <= 780) {
        r = 1;
        g = 0;
        b = 0;
    } else {
        return { r: 120, g: 0, b: 0 }; // IR: deep red
    }

    let factor = 1;
    if (wlNm >= 380 && wlNm < 420) {
        factor = 0.3 + 0.7 * (wlNm - 380) / (420 - 380);
    } else if (wlNm >= 420 && wlNm <= 700) {
        factor = 1;
    } else if (wlNm > 700 && wlNm <= 780) {
        factor = 0.3 + 0.7 * (780 - wlNm) / (780 - 700);
    }

    const gamma = 0.8;
    const to8bit = (c) => Math.max(0, Math.min(255, Math.round(255 * Math.pow(c * factor, gamma))));
    return { r: to8bit(r), g: to8bit(g), b: to8bit(b) };
}

function updateTelemetry(data) {
    const hClamped = Math.max(h, 0);
    const vAbs = Math.abs(v);
    const tempAtm = Number.isFinite(data.T) ? data.T : atmosphereState(hClamped).T;
    const rangeKm = hClamped / 1000;
    const angularMrad = hClamped > 0 ? (2 * Math.atan(sailRadius / hClamped) * 1000) : 0;
    const pointingTolMrad = hClamped > 0 ? (Math.atan(sailRadius / hClamped) * 1000) : 0;
    const beamRatio = data.wEff / Math.max(sailRadius, 1e-9);
    const dynQ = 0.5 * data.rho * vAbs * vAbs;
    const speedOfSound = Math.sqrt(GAMMA_AIR * R_SPEC * tempAtm);
    const mach = speedOfSound > 0 ? vAbs / speedOfSound : 0;
    const mu = airViscosity(tempAtm);
    const reynolds = mu > 0 ? (data.rho * vAbs * sailDiameter) / mu : 0;
    const tStag = tempAtm * (1 + (GAMMA_AIR - 1) / 2 * mach * mach);
    const heatFlux = sailArea > 0
        ? (AERO_K * Math.sqrt(Math.max(data.rho, 0) / RN) * Math.pow(vAbs, 3)) / sailArea
        : 0;
    const vEff = (data.pAbs > 0 && data.fLaser > 0) ? (2 * data.pAbs / data.fLaser) : 0;
    const isp = vEff / G0;
    const vc = v / C;
    const lambdaNm = observedLambdaNm(v);

    const formatMetric = (value, unit) => {
        if (!Number.isFinite(value)) return "n/a";
        const abs = Math.abs(value);
        let text = "0";
        if (abs > 0 && abs < 1e-4) {
            text = value.toExponential(6);
        } else if (abs < 1) {
            text = value.toFixed(6);
        } else if (abs < 1000) {
            text = value.toFixed(4);
        } else {
            text = value.toFixed(0);
        }
        return unit ? `${text} ${unit}` : text;
    };

    telH.innerText = (hClamped / 1000).toFixed(3) + " km";
    telRange.innerText = rangeKm.toFixed(3) + " km";
    telV.innerText = v.toFixed(1) + " m/s";
    telA.innerText = (data.accel / G0).toFixed(3) + " g";
    telVc.innerText = Number.isFinite(vc) ? vc.toFixed(6) : "n/a";
    if (telLambda) {
        const lambdaNm = observedLambdaNm(v);
        telLambda.innerText = Number.isFinite(lambdaNm) ? lambdaNm.toFixed(1) + " nm" : "n/a";
    }
    telPemit.innerText = (data.pEmit / 1e6).toFixed(3) + " MW";
    telPhit.innerText = (data.pHit / 1e6).toFixed(3) + " MW";
    telIrr.innerText = (data.irradiance / 1e6).toFixed(3) + " MW/m2";
    telIrr0.innerText = (data.irradiance0 / 1e6).toFixed(3) + " MW/m2";
    telPabs.innerText = (data.pAbs / 1e3).toFixed(3) + " kW";
    telW.innerText = formatMetric(data.wEff, "m");
    telAng.innerText = hClamped > 0 ? formatMetric(angularMrad, "mrad") : "n/a";
    telPtol.innerText = hClamped > 0 ? formatMetric(pointingTolMrad, "mrad") : "n/a";
    telBratio.innerText = formatMetric(beamRatio, "");
    telFhit.innerText = (data.fHit * 100).toFixed(2) + " %";
    telFl.innerText = data.fLaser.toExponential(3) + " N";
    telFd.innerText = data.fDrag.toExponential(3) + " N";
    telQ.innerText = (dynQ / 1000).toFixed(3) + " kPa";
    telMach.innerText = mach.toFixed(3);
    telRe.innerText = reynolds.toExponential(3);
    telTstag.innerText = tStag.toFixed(1) + " K";
    telQdot.innerText = (heatFlux / 1000).toFixed(3) + " kW/m2";
    telRho.innerText = data.rho.toExponential(3) + " kg/m3";
    telTemp.innerText = tempK.toFixed(1) + " K";
    telVe.innerText = vEff > 0 ? vEff.toFixed(1) + " m/s" : "n/a";
    telIsp.innerText = vEff > 0 ? isp.toFixed(1) + " s" : "n/a";
    telImp.innerText = impulseNs === 0 ? "0 N*s" : impulseNs.toExponential(3) + " N*s";
    telEhit.innerText = (energyHitJ / 1e6).toFixed(3) + " MJ";
    telEabs.innerText = (energyAbsJ / 1e6).toFixed(3) + " MJ";
    telEps.innerText = data.epsilon.toExponential(3) + " J/kg";
    costDisp.innerText = "$" + energyCostUSD.toFixed(2);
    telStatus.innerText = statusText;

    if (beamRadiusInput && beamRadiusOverride <= 0 && document.activeElement !== beamRadiusInput) {
        beamRadiusSyncing = true;
        setNumberInputValue(beamRadiusInput, data.wEff, true);
        beamRadiusSyncing = false;
    }
    lastTelemetry = {
        time: simElapsed,
        altitude: hClamped,
        range: hClamped,
        velocity: v,
        vOverC: vc,
        lambdaSailNm: lambdaNm,
        accel: data.accel,
        pEmit: data.pEmit,
        pHit: data.pHit,
        pAbs: data.pAbs,
        irradiance: data.irradiance,
        irradiance0: data.irradiance0,
        wEff: data.wEff,
        angularSize: angularMrad,
        pointingTol: pointingTolMrad,
        beamRatio,
        fHit: data.fHit,
        fLaser: data.fLaser,
        fDrag: data.fDrag,
        dynQ,
        mach,
        reynolds,
        tStag,
        heatFlux,
        rho: data.rho,
        tempK: tempK,
        vEff,
        isp,
        impulse: impulseNs,
        energyHit: energyHitJ,
        energyAbs: energyAbsJ,
        epsilon: data.epsilon,
        costUSD: energyCostUSD
    };
}

function triggerFailure(reason) {
    if (sailFailed) return;
    sailFailed = true;
    stopLaser(reason);
    explosionPending = true;
}

function stopLaser(reason) {
    if (reason) statusText = reason;
    laserOn = false;
    toggleBtn.textContent = "START LASER";
    toggleBtn.classList.remove('active');
}

toggleBtn.onclick = () => {
    if (sailFailed) return;
    if (simPaused && statusText !== "OK") {
        // allow restart after a failure by clearing pause manually
        simPaused = false;
        statusText = "OK";
    }
    laserOn = !laserOn;
    if (laserOn) simStarted = true;
    toggleBtn.textContent = laserOn ? "STOP LASER" : "START LASER";
    toggleBtn.classList.toggle('active', laserOn);
    
    // Unpause if we start laser
    if (laserOn && simPaused && statusText === "OK") {
        simPaused = false;
        if (pauseBtn) {
            pauseBtn.textContent = "PAUSE";
            pauseBtn.classList.remove('is-paused');
        }
    }
};

if (pauseBtn) {
    pauseBtn.addEventListener('click', () => {
        simPaused = !simPaused;
        pauseBtn.textContent = simPaused ? "RESUME" : "PAUSE";
        pauseBtn.classList.toggle('is-paused', simPaused);
    });
}

if (restartBtn) {
    restartBtn.addEventListener('click', () => {
        resetSimulationState();
        if (pauseBtn) {
            pauseBtn.textContent = "PAUSE";
            pauseBtn.classList.remove('is-paused');
        }
    });
}

/**
 * PHYSICS UPDATE
 */
function computeForces(stateH = h, stateV = v) {
    const hNow = stateH;
    const vNow = stateV;
    // --- 1. ATMOSPHERIC TRANSMISSION (Ground to Altitude h) ---
    // Blue light scatters. We assume the laser is at h=0 (Ground).
    // Simple model: Transmission improves as we get higher, but we are calculating
    // the loss from Ground UP TO the sail.
    // T_total = T_zenith ^ (AirMass_passed).
    // AirMass fraction remaining above h: P(h)/P(0).
    // Therefore AirMass passed = 1 - (P(h)/P(0)).
    const atm = atmosphereState(hNow);
    const P0 = 101325;
    const airMassPassed = 1.0 - (atm.P / P0);
    // Transmission factor from Ground(0) to Sail(h)
    const transmission = Math.pow(atmTransmissionZenith, airMassPassed);

    // --- 2. INCOHERENT BEAM OPTICS (Geometric Spreading) ---
    // The beam is a "cone" or "tube" defined by the ground mirror.
    // Width = Aperture + (Range * Divergence)
    const zRange = hNow; // Distance from ground laser to sail
    const divergenceRad = divergenceMrad / 1000;

    // The beam radius (1/e^2 approx equivalent for flat-top)
    let wEff = 0;
    let fHit = 0;

    if (useDiffractionBeam) {
        const beam = beamAtRange(zRange, apertureD);
        wEff = beam.wEff;
        fHit = beam.fHit;
    } else {
        wEff = (apertureD / 2) + (zRange * Math.tan(divergenceRad));
        if (sailRadius >= wEff) {
            fHit = 1.0;
        } else {
            fHit = (sailRadius * sailRadius) / (wEff * wEff);
        }
    }

    // Override logic (keep existing feature)
    if (beamRadiusOverride > 0) {
        wEff = beamRadiusOverride;
        if (sailRadius >= wEff) {
            fHit = 1.0;
        } else {
            fHit = (sailRadius * sailRadius) / (wEff * wEff);
        }
    }

    // --- 3. POWER CAPTURE ---
    // Geometric capture fraction (Area Sail / Area Beam)
    // For incoherent flat beams, if Sail < Beam, we catch ratio of areas.
    // If Sail > Beam, we catch 100%.
    const beamArea = Math.PI * wEff * wEff;

    // Apply atmospheric loss to the power arriving at altitude
    const sliderWatts = powerMW * 1e6;
    let pEmit = sliderWatts;
    let pHit = 0;

    // Logic for laser toggle
    if (laserOn) {
        // Power arriving at altitude = Emit * Transmission
        const pAtAltitude = pEmit * transmission;
        pHit = pAtAltitude * fHit;
    }

    // --- 4. ABLATIVE THRUST CALCULATION ---
    // Old Formula: F = 2P/c (Radiation Pressure) ~ 0.006 N/MW
    // New Formula: F = Cm * P_absorbed.
    // We assume the sail is black plastic (Absorptance ~ 1.0)

    // Coupling Coefficient Input is in N/MW, convert to N/W
    const Cm_N_W = useRadiationCoupling
        ? (2 * reflectance + absorptance) / C
        : (couplingCm / 1e6);

    // Thrust Force
    const fLaser = pHit * Cm_N_W;

    // --- 5. DRAG & GRAVITY (Standard) ---
    const irradiance = pHit / sailArea;
    const irradiance0 = irradiance; // Flat beam approx

    // Drag calculation
    const lambdaMfp = (KB * atm.T) / (Math.SQRT2 * Math.PI * AIR_DIAMETER * AIR_DIAMETER * Math.max(atm.P, 1e-9));
    const Kn = lambdaMfp / sailDiameter;
    const blend = Kn / (Kn + 1);
    const CdEff = (1 - blend) * CD_CONT + blend * CD_FM;
    const fDrag = 0.5 * CdEff * atm.rho * sailArea * vNow * Math.abs(vNow);

    const local_g = MU / Math.pow(RE + hNow, 2);
    const fGrav = massKg * local_g;
    const invMass = 1 / Math.max(massKg, 1e-9);

    // Net Acceleration
    const accel = (fLaser - fDrag - fGrav) * invMass;
    const epsilon = 0.5 * vNow * vNow - MU / (RE + hNow);

    return {
        accel,
        pEmit,
        pHit,
        irradiance,
        irradiance0,
        wEff,
        fHit,
        fLaser,
        fDrag,
        rho: atm.rho,
        T: atm.T,
        transmission,
        epsilon
    };
}

function updatePhysics(dt) {
    powerMW = parseFloat(pSlider.value);
    apertureD = parseFloat(dSlider.value);

    if (couplingMode === "lambda") {
        const factor = dopplerFactor(v / C);
        const targetNm = Math.max(0, couplingTarget);
        const desiredNm = targetNm / factor;
        const minNm = parseFloat(wavelengthInput.min);
        const maxNm = parseFloat(wavelengthInput.max);
        const nextNm = clampValue(desiredNm, minNm, maxNm);
        setNumberInputValue(wavelengthInput, nextNm, true);
        applyWavelengthNm(nextNm);
    } else if (couplingMode !== "manual") {
        const dataAuto = computeForces();
        const fHitSafe = Math.max(dataAuto.fHit || 0, 1e-9);
        const transmissionSafe = Math.max(dataAuto.transmission || 0, 1e-9);
        let targetP = null;

        if (couplingMode === "phit") {
            targetP = couplingTarget * 1e6;
        } else if (couplingMode === "ipeak") {
            const targetIrr = Math.max(couplingTarget, 0);
            targetP = targetIrr * sailArea;
        } else if (couplingMode === "temp") {
            const targetIrr = tempLimitedIrradiance(couplingTarget);
            targetP = targetIrr * sailArea;
        }

        if (Number.isFinite(targetP) && targetP >= 0) {
            const desiredEmitW = targetP / (transmissionSafe * fHitSafe);
            const desiredMW = desiredEmitW / 1e6;
            const minMW = parseFloat(pSlider.min);
            const maxMW = parseFloat(pSlider.max);
            powerMW = clampValue(desiredMW, minMW, maxMW);
            setNumberInputValue(pSlider, powerMW, true);
        }
    }
    if (couplingMode !== "manual" && couplingMode !== "lambda") {
        pModeDisp.textContent = "auto";
    } else {
        pModeDisp.textContent = "emit";
    }

    if (!isPaused()) statusText = "OK";

    let data = computeForces();

    // Dynamics (Semi-implicit Euler with substeps to avoid drag spikes)
    if (dt > 0 && !isPaused()) {
        let remaining = dt;
        let steps = 0;
        let maxSubstepsAllowed = MAX_SUBSTEPS;
        while (remaining > 0 && steps < maxSubstepsAllowed) {
            const dataStart = computeForces();
            const accelAbs = Math.abs(dataStart.accel);
            let subDt = remaining;
            let maxDtForAccel = Infinity;
            let maxDtForDrag = Infinity;
            let maxDtForThermal = Infinity;
            let maxDtForThermalStability = Infinity;
            if (accelAbs > 0) {
                maxDtForAccel = MAX_DV_PER_STEP / accelAbs;
                subDt = Math.min(subDt, maxDtForAccel);
            }
            // Limit timestep when drag is stiff near terminal velocity.
            const vAbs = Math.abs(v);
            const massSafe = Math.max(massKg, 1e-9);
            if (vAbs > 1e-6) {
                const dragRate = (2 * Math.abs(dataStart.fDrag)) / (massSafe * vAbs);
                if (dragRate > 0) {
                    maxDtForDrag = DRAG_DT_SAFETY / dragRate;
                    subDt = Math.min(subDt, maxDtForDrag);
                }
            }
            // Limit timestep for thermal stability.
            const pAbsStart = absorptance * dataStart.pHit;
            const tEnvStart = environmentTemp(dataStart.rho, dataStart.T);
            const pRadStart = emissivity * SIGMA * (2 * sailArea) * (Math.pow(tempK, 4) - Math.pow(tEnvStart, 4));
            const pAeroStart = AERO_K * Math.sqrt(Math.max(dataStart.rho, 0) / RN) * Math.pow(vAbs, 3);
            const hConvStart = convectiveH(dataStart.rho);
            const pConvStart = hConvStart * (2 * sailArea) * (dataStart.T - tempK);
            const dTdtStart = (pAbsStart + pAeroStart + pConvStart - pRadStart) / (massSafe * CP);
            if (Number.isFinite(dTdtStart) && Math.abs(dTdtStart) > 0) {
                maxDtForThermal = MAX_DTEMP_PER_STEP / Math.abs(dTdtStart);
                subDt = Math.min(subDt, maxDtForThermal);
            }
            const dPdT = -((2 * sailArea * hConvStart) + (4 * emissivity * SIGMA * (2 * sailArea) * Math.pow(Math.max(tempK, 0), 3)));
            if (Number.isFinite(dPdT) && Math.abs(dPdT) > 0) {
                maxDtForThermalStability = THERMAL_DT_SAFETY * (massSafe * CP) / Math.abs(dPdT);
                subDt = Math.min(subDt, maxDtForThermalStability);
            }

            const maxDtThermalAllowed = Math.min(maxDtForThermal, maxDtForThermalStability);
            if (Number.isFinite(maxDtThermalAllowed) && maxDtThermalAllowed > 0) {
                const requiredSteps = Math.ceil(remaining / maxDtThermalAllowed);
                if (requiredSteps > maxSubstepsAllowed) {
                    maxSubstepsAllowed = Math.min(MAX_SUBSTEPS_THERMAL, Math.max(MAX_SUBSTEPS, requiredSteps));
                }
            }

            const minDt = remaining / (maxSubstepsAllowed - steps);
            const minSafe = Math.min(maxDtForAccel, maxDtForDrag, maxDtForThermal, maxDtForThermalStability);
            if (minDt <= minSafe) {
                subDt = Math.max(subDt, minDt);
            }

            const vMid = v + 0.5 * dataStart.accel * subDt;
            const hMid = h + 0.5 * v * subDt;
            const dataMid = computeForces(hMid, vMid);

            v += dataMid.accel * subDt;
            h += vMid * subDt;
            if (h < 0) {
                h = 0;
                if (v < 0) v = 0;
            }

            const pAbs = absorptance * dataMid.pHit;
            if (laserOn) {
                energyCostUSD += (dataMid.pEmit / 1000) * (subDt / 3600) * USD_PER_KWH;
                impulseNs += dataMid.fLaser * subDt;
                energyHitJ += dataMid.pHit * subDt;
                energyAbsJ += pAbs * subDt;
            }

            // Thermal lumped model
            const tEnv = environmentTemp(dataMid.rho, dataMid.T);
            const pRad = emissivity * SIGMA * (2 * sailArea) * (Math.pow(tempK, 4) - Math.pow(tEnv, 4));
            const pAero = AERO_K * Math.sqrt(Math.max(dataMid.rho, 0) / RN) * Math.pow(Math.abs(vMid), 3);
            const hConv = convectiveH(dataMid.rho);
            const pConv = hConv * (2 * sailArea) * (dataMid.T - tempK);
            const dTdt = (pAbs + pAero + pConv - pRad) / (massSafe * CP);
            const nextTemp = tempK + dTdt * subDt;
            if (Number.isFinite(tempLimitK) && nextTemp > tempLimitK) {
                tempK = tempLimitK;
                triggerFailure("FAILED: over-temp");
                break;
            }
            if (!Number.isFinite(nextTemp) || nextTemp < 0) {
                triggerFailure("FAILED: temp NaN");
                break;
            }
            tempK = nextTemp;
            if (!Number.isFinite(tempK)) {
                triggerFailure("FAILED: temp NaN");
                break;
            }

            remaining -= subDt;
            steps += 1;
        }
        data = computeForces();
    }

    if (!isPaused() && !sailFailed) {
        if (!Number.isFinite(tempK) || tempK < 0) {
            triggerFailure("FAILED: temp NaN");
        } else if (Number.isFinite(tempLimitK) && tempK > tempLimitK) {
            triggerFailure("FAILED: over-temp");
        } else if (Number.isFinite(maxIrradianceLimit) && data.irradiance0 > maxIrradianceLimit) {
            triggerFailure("FAILED: over-irradiance");
        } else if (data.epsilon > 0 && v > 0) {
            if (stopOnEscape) {
                simPaused = true;
                stopLaser("ESCAPE");
            } else {
                statusText = "ESCAPE (CONTINUING)";
            }
        }
    }

    const telemetryData = {
        accel: data.accel,
        pEmit: data.pEmit,
        pHit: data.pHit,
        irradiance: data.irradiance,
        irradiance0: data.irradiance0,
        wEff: data.wEff,
        fHit: data.fHit,
        fLaser: data.fLaser,
        fDrag: data.fDrag,
        rho: data.rho,
        T: data.T,
        epsilon: data.epsilon,
        pAbs: absorptance * data.pHit
    };

    return { wEff: data.wEff, rho: data.rho, telemetry: telemetryData };
}

/**
 * RENDERING
 */
function draw(wEff, rho) {
    // 1. Background Sky (Altitude-based gradient)
    const alt = Math.max(h, 0);
    const t = Math.max(0, Math.min(1, alt / 120000)); // 0..120 km
    const skyTop = {
        r: Math.round(0 + (10 - 0) * (1 - t)),
        g: Math.round(0 + (60 - 0) * (1 - t)),
        b: Math.round(0 + (140 - 0) * (1 - t))
    };
    const skyBottom = {
        r: Math.round(0 + (5 - 0) * (1 - t)),
        g: Math.round(0 + (20 - 0) * (1 - t)),
        b: Math.round(0 + (60 - 0) * (1 - t))
    };
    const gradSky = ctx.createLinearGradient(0, 0, 0, height);
    gradSky.addColorStop(0, `rgb(${skyTop.r}, ${skyTop.g}, ${skyTop.b})`);
    gradSky.addColorStop(1, `rgb(${skyBottom.r}, ${skyBottom.g}, ${skyBottom.b})`);
    ctx.fillStyle = gradSky;
    ctx.fillRect(0, 0, width, height);

    // 2. Camera setup (Sail is centered vertically)
    const centerY = height / 2;
    const sailVisualHalf = 40;

    if (explosionPending) {
        explosionPending = false;
        explosionOrigin = { x: width / 2, y: centerY };
        const beamRgb = wavelengthToRgb(LAMBDA);
        spawnExplosionParticles(explosionOrigin.x, explosionOrigin.y, beamRgb);
    }
    
      // 3. Draw Laser Beam (rendered as a near-parallel column at the sail)
    if (laserOn) {
        const beamRgb = wavelengthToRgb(LAMBDA);
        const beamColor = `rgba(${beamRgb.r}, ${beamRgb.g}, ${beamRgb.b}, `;
        
        // Scale beam width correctly to the sail's drawn size (sail radius = 40 px visual)
        const visualWidth = (wEff / Math.max(sailRadius, 1e-6)) * 40;
        let beamHalf = Math.max(visualWidth, 6);
        if (!Number.isFinite(beamHalf)) beamHalf = 6;

        // Intensity-based fading: Opacity scales with Power and 1/Area
        const w0 = Math.max(apertureD / 2, 1e-3);
        let intensityRatio = Math.pow(w0 / Math.max(wEff, 1e-6), 2);
        if (!Number.isFinite(intensityRatio)) intensityRatio = 0;
        
        const pRef = 0.07; // Reference power (MW) for visibility
        const currentPower = laserOn ? powerMW : 0;
        let intensity = (currentPower / pRef) * intensityRatio;
        if (!Number.isFinite(intensity)) intensity = 0;
        
        const coreAlpha = Math.max(0, Math.min(0.9, intensity * 0.8));
        const fringeAlpha = Math.max(0, Math.min(0.5, intensity * 0.4));

        ctx.save();
        ctx.globalCompositeOperation = "lighter";
        
        // Create horizontal gradient for a realistic beam profile (hot center, soft fringe)
        // Stops are adjusted to fill the beamHalf width properly
        const gradX = ctx.createLinearGradient(width / 2 - beamHalf, 0, width / 2 + beamHalf, 0);
        gradX.addColorStop(0, "rgba(0,0,0,0)");
        gradX.addColorStop(0.15, beamColor + "0)");
        gradX.addColorStop(0.35, beamColor + (fringeAlpha * 0.5).toFixed(6) + ")");
        gradX.addColorStop(0.5, `rgba(255, 255, 255, ${coreAlpha.toFixed(6)})`); // Intense hot core
        gradX.addColorStop(0.65, beamColor + (fringeAlpha * 0.5).toFixed(6) + ")");
        gradX.addColorStop(0.85, beamColor + "0)");
        gradX.addColorStop(1, "rgba(0,0,0,0)");
        
        ctx.fillStyle = gradX;

        // Main beam (Ground to Sail)
        ctx.fillRect(width / 2 - beamHalf, centerY, beamHalf * 2, height - centerY);

        // Spillover (Sail to Space) - if beam is wider than sail
        if (beamHalf > sailVisualHalf) {
            // Left wing
            ctx.fillRect(width / 2 - beamHalf, 0, beamHalf - sailVisualHalf, centerY);
            // Right wing
            ctx.fillRect(width / 2 + sailVisualHalf, 0, beamHalf - sailVisualHalf, centerY);
        }
        ctx.restore();
    }

    // 4. Draw Sail
    if (!sailFailed) {
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(width/2 - 40, centerY);
        ctx.lineTo(width/2 + 40, centerY);
        ctx.stroke();
        
        // Glow effect
        if (laserOn && !isPaused()) {
            const beamRgb = wavelengthToRgb(LAMBDA);
            ctx.shadowBlur = 15;
            ctx.shadowColor = `rgb(${beamRgb.r}, ${beamRgb.g}, ${beamRgb.b})`;
            ctx.stroke();
            ctx.shadowBlur = 0;
        }
    }
    
    updateAndDrawAblationParticles(centerY, sailVisualHalf);
    updateAndDrawExplosionParticles();

    // 5. Altitude Markers (Reference motion)
    ctx.fillStyle = "rgba(255,255,255,0.3)";
    ctx.font = "12px monospace";
    const step = 100; // meters
    const startIdx = Math.floor(h / step) - 10;
    for(let i = 0; i < 25; i++) {
        const markerH = (startIdx + i) * step;
        const screenY = centerY + (h - markerH) * 5; // Move markers relative to sail
        if (screenY > 0 && screenY < height) {
            ctx.fillRect(width/2 + 60, screenY, 10, 1);
            if (markerH % 500 === 0) {
                ctx.fillText(markerH + " m", width/2 + 75, screenY + 4);
            }
        }
    }

    // Ground line if close
    const groundY = centerY + h * 5;
    if (groundY < height) {
        ctx.fillStyle = "#332211";
        ctx.fillRect(0, groundY, width, height - groundY);
    }
}

/**
 * MAIN LOOP
 */
let lastTime = performance.now();
const fixedDt = 0.02;
const maxStepsPerFrame = 400;
function loop(now) {
    const realDt = (now - lastTime) / 1000;
    lastTime = now;
    const speedValue = parseFloat(speedSlider.value);
    if (Number.isFinite(speedValue)) timeScale = speedValue;

    let physResult = lastPhysResult;
    if (!inputHold) {
        physResult = updatePhysics(0);
        lastPhysResult = physResult;
    }
    if (!isPaused() && simStarted) {
        // Fixed-step integration with a per-frame step cap for stability
        const simDt = Math.min(realDt, 0.05) * timeScale;
        simAccumulator = Math.min(simAccumulator + simDt, maxStepsPerFrame * fixedDt);
        const steps = Math.floor(simAccumulator / fixedDt);
        for (let i = 0; i < steps; i++) {
            physResult = updatePhysics(fixedDt);
            if (simPaused) break;
        }
        simAccumulator -= steps * fixedDt;
        simElapsed += steps * fixedDt;
    }
    
    if (physResult && physResult.telemetry) {
        updateTelemetry(physResult.telemetry);
    }

    realTimeDisp.innerText = formatClock(simElapsed);

    draw(physResult.wEff, physResult.rho);
    drawScope();
    pushPlotSample();
    drawPlot();
    requestAnimationFrame(loop);
}

const scopeCanvas = document.getElementById('scope-canvas');
const scopeCtx = scopeCanvas ? scopeCanvas.getContext('2d') : null;

function drawScope() {
    if (!scopeCanvas || !scopeCtx) return;

    // Auto-resize
    const rect = scopeCanvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    if (scopeCanvas.width !== rect.width * dpr || scopeCanvas.height !== rect.height * dpr) {
        scopeCanvas.width = rect.width * dpr;
        scopeCanvas.height = rect.height * dpr;
    }
    
    const w = scopeCanvas.width;
    const h = scopeCanvas.height;
    const t = performance.now() / 150; // Animation speed

    scopeCtx.clearRect(0, 0, w, h);

    // Color based on wavelength
    let r = 100, g = 100, b = 100;
    if (laserOn) {
        const rgb = wavelengthToRgb(LAMBDA);
        r = rgb.r; g = rgb.g; b = rgb.b;
    } else {
        // Dim idle color
        r = 60; g = 60; b = 60;
    }
    
    scopeCtx.lineWidth = 2 * dpr;
    scopeCtx.lineCap = "round";

    // Draw 5 lines
    const lineCount = 5;
    const spacing = h / (lineCount + 1);
    
    for (let i = 0; i < lineCount; i++) {
        const yBase = spacing * (i + 1);
        
        // Phase logic
        let phase = t; 
        let amplitude = 6 * dpr;
        
        if (!useDiffractionBeam) {
            // Incoherent: Random phase offset per line
            // We use a fixed seed based on 'i' so lines stay distinct but consistent
            phase += (i * 1.5) + Math.sin(t * 0.5 + i); 
            // Incoherent often has varying amplitude (fading coherence)
            // amplitude *= (0.8 + 0.4 * Math.sin(t * 0.2 + i * 99)); 
        }

        scopeCtx.beginPath();
        scopeCtx.strokeStyle = `rgba(${r}, ${g}, ${b}, 0.8)`;
        
        for (let x = 0; x < w; x += 2 * dpr) {
            // Sine wave equation
            const y = yBase + Math.sin(x * 0.05 + phase) * amplitude;
            if (x === 0) scopeCtx.moveTo(x, y);
            else scopeCtx.lineTo(x, y);
        }
        scopeCtx.stroke();
    }
}

requestAnimationFrame(loop);

/* TUTORIAL SYSTEM */
const tutorialBtn = document.getElementById('tutorial-btn');
const tutorialOverlay = document.getElementById('tutorial-overlay');
const tutorialBox = document.getElementById('tutorial-box');
const tutorialText = document.getElementById('tutorial-text');
const tutorialNext = document.getElementById('tutorial-next');
const tutorialSkip = document.getElementById('tutorial-skip');
const tutorialBack = document.getElementById('tutorial-back');
const tutorialLearnMore = document.getElementById('tutorial-learn-more');
const tutorialInfoBox = document.getElementById('tutorial-info-box');
const tutorialInfoContent = document.getElementById('tutorial-info-content');
const tutorialInfoClose = document.getElementById('tutorial-info-close');
let animFrame = null;
let animFrame2 = null;
let animFrame3 = null;
let animFrame4 = null;
let animFrame5 = null;
let animFrame6 = null;
let animFrame7 = null;
let animFrame8 = null;
let animFrame9 = null;
let animFrame10 = null;
let animFrame11 = null;
let animFrame12 = null;

const tutorialSteps = [
    {
        target: null,
        msg: "<strong>Welcome to the 1-Dimensional Light Sail Simulation.</strong><br><br>This tool simulates the propulsion of a light sail by a high-power ground-based laser, calculating physics in real-time."
    },
    {
        target: "#telemetry-island",
        msg: "The <strong>Telemetry</strong> panel shows real-time data about the sail's state, including altitude, velocity, acceleration, and laser performance metrics. Click <strong>Learn More</strong> for a full field-by-field explanation to learn about these data sets.",
        learnMore: "telemetry"
    },
    {
        target: "#plot-island",
        msg: "The <strong>Telemetry Plot</strong> allows you to visualize how different variables change over time or against each other. You can customize the axes and download the data."
    },
    {
        target: "#wavefront-island",
        msg: "The <strong>Wavefront Analysis</strong> panel visualizes the beam's coherence and wavefront properties in real-time.",
        learnMore: "wavefront"
    },
    {
        target: "#mission-escape-island",
        msg: "The <strong>XERIONYX/STARSHOT</strong> toggle lets you switch between preset configurations like 'XERIONYX' (Atmospheric) or 'STARSHOT' (Interstellar). You can also toggle whether the simulation stops upon reaching Erath's escape velocity. Click <strong>Learn More</strong> for mission details.",
        learnMore: "mission"
    },
    {
        target: "#coupling-island",
        msg: "The <strong>Coupling</strong> control is a powerful feature. Instead of just setting a fixed laser power, you can automatically regulate the laser power to maintain a target Sail Temperature, Peak Irradiance, P_Hit (Actual power hitting the sail) or the wavelength which the sail sees (great for STARSHOT near light speed mission where the light gets red-shifted)."
    },
    {
        target: "#controls-island",
        msg: "The <strong>Main Controls</strong> give you manual command over the Laser (Power, Aperture, Wavelength) and Sail parameters (Diameter, Mass, Reflectance). You can also control the Simulation speed, start/stop the laser, and pause or restart.",
        learnMore: "main_controls"
    }
];

let currentStepIndex = -1;

function updateTutorialStep() {
    const step = tutorialSteps[currentStepIndex];
    if (!step) return;

    // Helper to apply changes
    const applyStep = () => {
        // Clear previous highlight
        document.querySelectorAll('.tutorial-highlight').forEach(el => el.classList.remove('tutorial-highlight'));
        
        // Set Text
        tutorialText.innerHTML = step.msg;
        
        // Highlight new target
        if (step.target) {
            const el = document.querySelector(step.target);
            if (el) el.classList.add('tutorial-highlight');
        }

        // Button Visibility & Text
        if (tutorialBack) {
            tutorialBack.style.display = currentStepIndex === 0 ? "none" : "block";
        }

        if (tutorialLearnMore) {
            if (step.learnMore) {
                tutorialLearnMore.classList.add('is-visible');
            } else {
                tutorialLearnMore.classList.remove('is-visible');
            }
        }

        if (currentStepIndex === tutorialSteps.length - 1) {
            tutorialNext.textContent = "Finish";
        } else {
            tutorialNext.textContent = "Next";
        }
    };

    // If it's the first step, apply immediately (no fade out/in sequence)
    // The box itself is fading in, so text doesn't need to double-fade
    if (currentStepIndex === 0) {
        if (tutorialText) tutorialText.classList.remove('fade-out');
        applyStep();
        return;
    }

    // Otherwise, do the smooth text transition
    if (tutorialText) {
        tutorialText.classList.add('fade-out');
        setTimeout(() => {
            applyStep();
            tutorialText.classList.remove('fade-out');
        }, 200);
    } else {
        applyStep();
    }
}

function startTutorial() {
    currentStepIndex = 0;
    tutorialOverlay.classList.add('active');
    tutorialOverlay.setAttribute('aria-hidden', 'false');
    tutorialBox.classList.add('active');
    tutorialBox.setAttribute('aria-hidden', 'false');
    updateTutorialStep();
}

function endTutorial() {
    currentStepIndex = -1;
    document.querySelectorAll('.tutorial-highlight').forEach(el => el.classList.remove('tutorial-highlight'));
    tutorialOverlay.classList.remove('active');
    tutorialOverlay.setAttribute('aria-hidden', 'true');
    tutorialBox.classList.remove('active');
    tutorialBox.setAttribute('aria-hidden', 'true');
    tutorialInfoBox.classList.remove('active');
    tutorialInfoBox.setAttribute('aria-hidden', 'true');
}

tutorialBtn.addEventListener('click', startTutorial);

tutorialNext.addEventListener('click', () => {
    currentStepIndex++;
    if (currentStepIndex >= tutorialSteps.length) {
        endTutorial();
    } else {
        updateTutorialStep();
    }
});

if (tutorialBack) {
    tutorialBack.addEventListener('click', () => {
        if (currentStepIndex > 0) {
            currentStepIndex--;
            updateTutorialStep();
        }
    });
}

if (tutorialLearnMore) {
    
    const closeTutorialInfoBox = () => {
        if (!tutorialInfoBox) return;
        if (!tutorialInfoBox.classList.contains('active')) return;
        tutorialInfoBox.classList.remove('active');
        tutorialInfoBox.setAttribute('aria-hidden', 'true');
        if (animFrame) cancelAnimationFrame(animFrame);
        if (animFrame2) cancelAnimationFrame(animFrame2);
        if (animFrame3) cancelAnimationFrame(animFrame3);
        if (animFrame4) cancelAnimationFrame(animFrame4);
        if (animFrame5) cancelAnimationFrame(animFrame5);
        if (animFrame6) cancelAnimationFrame(animFrame6);
        if (animFrame7) cancelAnimationFrame(animFrame7);
        if (animFrame8) cancelAnimationFrame(animFrame8);
        if (animFrame9) cancelAnimationFrame(animFrame9);
        if (animFrame10) cancelAnimationFrame(animFrame10);
        if (animFrame11) cancelAnimationFrame(animFrame11);
        if (animFrame12) cancelAnimationFrame(animFrame12);
        animFrame = null;
        animFrame2 = null;
        animFrame3 = null;
        animFrame4 = null;
        animFrame5 = null;
        animFrame6 = null;
        animFrame7 = null;
        animFrame8 = null;
        animFrame9 = null;
        animFrame10 = null;
        animFrame11 = null;
        animFrame12 = null;
    };

    const openTutorialInfo = (learnMoreKey) => {
        if (!learnMoreKey || !tutorialInfoBox || !tutorialInfoContent) return;
        if (learnMoreKey === "telemetry") {
            tutorialInfoContent.innerHTML = `
                    <h2>Telemetry Panel Reference</h2>
                    <p>Real-time physics data explained. Two complex concepts determine your efficiency: <strong>Doppler Shift</strong> and <strong>Beam Capture</strong>.</p>

                    <h3 style="color:#fff; margin-top:30px;">1. Doppler Shift (_sail)</h3>
                    <p>As the sail accelerates away near relativistic speeds, it "runs away" from the light waves. The waves appear stretched (redshifted) to the sail.</p>

                    <div class="tutorial-info-animation">
                        <canvas id="tutorial-anim-doppler" style="width:100%; height:100%;"></canvas>
                    </div>

                    <p><strong>Impact:</strong> The sail sees a "redder" laser than what you fired. If the wavelength shifts too much, the sail's coating might stop reflecting/absorbing effectively.</p>

                    <h3 style="color:#fff; margin-top:30px;">2. Beam Capture (f_hit)</h3>
                    <p>The laser beam spreads out over distance (diffraction). Eventually, the spot becomes larger than the sail itself.</p>

                    <div class="tutorial-info-animation">
                        <canvas id="tutorial-anim-capture" style="width:100%; height:100%;"></canvas>
                    </div>

                    <p><strong>Beam/Sail Ratio:</strong> When this is > 1.0, the beam overfills the sail. The energy missing the sail is wasted (P_hit drops), reducing acceleration.</p>

                    <h3 style="color:#fff; margin-top:30px;">3. Aerodynamics & Shockwaves</h3>
                    <p>In the atmosphere, speed matters. At supersonic speeds (Mach > 1), air cannot move out of the way fast enough, forming shockwaves.</p>

                    <div class="tutorial-info-animation">
                        <canvas id="tutorial-anim-aero" style="width:100%; height:100%;"></canvas>
                    </div>

                    <p><strong>Mach Cone:</strong> A shockwave forms, causing a massive spike in Drag and Stagnation Temperature (T_stag). The sail must survive this intense heat.</p>

                    <h3 style="color:#fff; margin-top:30px;">4. Pointing Stability</h3>
                    <p>Hitting a small target from thousands of kilometers away requires extreme precision. As range increases, the "Angular Size" of the sail drops.</p>

                    <div class="tutorial-info-animation">
                        <canvas id="tutorial-anim-pointing" style="width:100%; height:100%;"></canvas>
                    </div>

                    <p><strong>Jitter:</strong> Even tiny vibrations (jitter) at the source translate to missing the target completely at long range. The "Pointing Tol" metric tells you how steady you need to be.</p>

                    <h3 style="color:#fff; margin-top:30px;">5. Orbital Energy</h3>
                    <p>To escape Earth, the sail must climb out of the "Gravity Well". The specific energy  becomes positive when speed is high enough.</p>

                    <div class="tutorial-info-animation">
                        <canvas id="tutorial-anim-orbit" style="width:100%; height:100%;"></canvas>
                    </div>

                    <h3 style="color:#fff; margin-top:30px;">Field Glossary</h3>
                    <p><strong>Altitude (km):</strong> Height above sea level. This drives the atmosphere model (density, temperature, pressure), which in turn affects drag and heating.</p>
                    <p><strong>LOS Range (km):</strong> Line-of-sight distance from the ground laser to the sail. In this 1D vertical model it equals altitude, and it controls beam spreading and transmission losses.</p>
                    <p><strong>Velocity (m/s):</strong> Vertical speed of the sail. Positive is upward; negative is downward. Used directly for drag, Mach number, heating, and energy.</p>
                    <p><strong>Accel (g):</strong> Net acceleration expressed in g's (Earth gravity units). This combines laser thrust, drag, and gravity to show the instantaneous push on the sail.</p>
                    <p><strong>Sim Time (hh:mm:ss):</strong> Elapsed simulation time (not wall clock). It advances faster or slower depending on the Time Speed control.</p>
                    <p><strong>v/c (unitless):</strong> Velocity divided by the speed of light. This is a convenient relativistic scale indicator even though the sim is non-relativistic.</p>
                    <p><strong>_sail (nm):</strong> Observed laser wavelength at the sail, including Doppler shift. As the sail recedes at relativistic speed, the light redshifts to longer wavelengths.</p>

                    <h3 style="color:#fff; margin-top:30px;">Laser Power & Beam</h3>
                    <p><strong>P_emit (MW):</strong> Laser power emitted at the source (before atmosphere). This is the output set by the power control or the auto-coupling logic.</p>
                    <p><strong>P_hit (MW):</strong> Power that actually reaches and is intercepted by the sail after atmospheric transmission and beam capture losses.</p>
                    <p><strong>P_abs (kW):</strong> Power absorbed by the sail material (P_hit  absorptance). This contributes to thermal heating and the ablation thrust model.</p>
                    <p><strong>I_avg (MW/m):</strong> Average irradiance over the sail area (P_hit / sail area). It reflects overall energy loading across the sail.</p>
                    <p><strong>I_peak (MW/m):</strong> Peak irradiance at the beam center. In the current flat-beam model this equals I_avg, but it is the value checked against safety limits and used for coupling targets.</p>
                    <p><strong>Beam radius (m):</strong> Effective beam spot radius at the sail (1/e^2). Smaller means tighter focus and higher irradiance.</p>
                    <p><strong>Angular size (mrad):</strong> Apparent angular diameter of the sail as seen from the laser (2atan(r_sail / range)). This gives a sense of how hard it is to hit the sail optically.</p>
                    <p><strong>Pointing tol (mrad):</strong> Half-angle pointing tolerance that still keeps the beam centered on the sail. Larger values mean easier targeting.</p>
                    <p><strong>Beam/sail ratio (unitless):</strong> Beam radius divided by sail radius. Values &lt; 1 mean the beam is smaller than the sail (good capture); values &gt; 1 mean the beam overfills the sail.</p>
                    <p><strong>Capture f_hit (unitless):</strong> Fraction of beam power captured by the sail. It ranges from 0 to 1 and is derived from the beam/sail size ratio.</p>

                    <h3 style="color:#fff; margin-top:30px;">Forces & Aero</h3>
                    <p><strong>F_laser (N):</strong> Thrust from the laser, computed using the coupling coefficient (or radiation coupling). This is the main propulsive force.</p>
                    <p><strong>F_drag (N):</strong> Aerodynamic drag force opposing motion. It depends on air density, velocity, and the drag model (continuum/free-molecular blend).</p>
                    <p><strong>Dyn pressure (kPa):</strong> Dynamic pressure q = 0.5v. It indicates aerodynamic loading and scales strongly with speed and density.</p>
                    <p><strong>Mach (unitless):</strong> Speed divided by the local speed of sound. Useful for understanding compressibility effects and heating regime.</p>
                    <p><strong>Re (unitless):</strong> Reynolds number based on sail diameter. It describes the flow regime and helps contextualize drag behavior.</p>

                    <h3 style="color:#fff; margin-top:30px;">Thermal State</h3>
                    <p><strong>T_stag (K):</strong> Stagnation temperature estimate from compressible flow. This is the temperature air would reach if it were brought to rest isentropically.</p>
                    <p><strong>Heat flux (kW/m):</strong> Aerodynamic heating rate applied to the sail surface from the model. Higher values rapidly raise temperature.</p>
                    <p><strong>Density (kg/m):</strong> Local atmospheric density from the standard atmosphere model. It drives drag and convective heating.</p>
                    <p><strong>Temp (K):</strong> Sail temperature from the thermal model (radiation, convection, absorption). This is the primary variable for thermal limits.</p>

                    <h3 style="color:#fff; margin-top:30px;">Propulsion & Energy</h3>
                    <p><strong>V_eff (m/s):</strong> Effective exhaust velocity implied by the coupling model. It is derived from absorbed power and thrust (2P_abs / F_laser).</p>
                    <p><strong>Isp (s):</strong> Specific impulse derived from V_eff / g0. It is a traditional propulsion efficiency metric.</p>
                    <p><strong>Impulse (Ns):</strong> Cumulative thrust over time (integral of F_laser). It reflects total momentum delivered to the sail.</p>
                    <p><strong>E_hit (MJ):</strong> Total energy delivered to the sail (integrated P_hit over time).</p>
                    <p><strong>E_abs (MJ):</strong> Total energy absorbed by the sail (integrated P_abs over time). This is what drives heating and ablation.</p>
                    <p><strong>Electric Cost (USD):</strong> Estimated electricity cost based on emitted power and the USD/kWh assumption. It accumulates only while the laser is on.</p>

                    <h3 style="color:#fff; margin-top:30px;">Orbit & Status</h3>
                    <p><strong>Escape epsilon (J/kg):</strong> Specific orbital energy  = v/2  /(R + h). Positive values mean the sail is on an escape trajectory.</p>
                    <p><strong>Status:</strong> Simulation state (OK, ESCAPE, or failure reason). Failures can come from overheating or irradiance limits.</p>
                `;

            // --- 1. Doppler Animation ---
            const canvasDop = document.getElementById('tutorial-anim-doppler');
            if (canvasDop) {
                const ctxDop = canvasDop.getContext('2d');
                let timeDop = 0;
                const drawDop = () => {
                    const dpr = window.devicePixelRatio || 1;
                    const rect = canvasDop.getBoundingClientRect();
                    canvasDop.width = rect.width * dpr; canvasDop.height = rect.height * dpr;
                    const w = canvasDop.width / dpr; const h = canvasDop.height / dpr;
                    ctxDop.resetTransform(); ctxDop.scale(dpr, dpr); ctxDop.clearRect(0, 0, w, h);
                    
                    timeDop += 0.01;
                    const centerY = h / 2;
                    
                    // Smooth oscillation between 0 and 1 for gentle accel/decel (no negative velocity)
                    const cycle = (timeDop % 6) / 6; // 0..1 over a longer period
                    const speedFactor = 0.5 - 0.5 * Math.cos(cycle * Math.PI * 2);
                    
                    // Visual Elements
                    const sourceX = 60;
                    const sailX = w - 60;
                    
                    // Draw Laser Source
                    ctxDop.fillStyle = '#222';
                    ctxDop.fillRect(sourceX - 20, centerY - 15, 20, 30);
                    ctxDop.fillStyle = '#aaa';
                    ctxDop.textAlign = 'center'; ctxDop.font = '10px monospace';
                    ctxDop.fillText("SOURCE (450nm)", sourceX - 10, centerY + 30);

                    // Draw Sail
                    ctxDop.fillStyle = '#eee';
                    ctxDop.fillRect(sailX, centerY - 25, 4, 50);
                    const shiftedNm = 450 * Math.sqrt((1+speedFactor*0.5)/(1-speedFactor*0.5));
                    ctxDop.fillText(`OBSERVED (${Math.round(shiftedNm)}nm)`, sailX, centerY + 40);
                    ctxDop.fillStyle = '#666';
                    ctxDop.fillText(`v = ${(speedFactor * 0.5 * 3e8 / 1e8).toFixed(2)}c`, sailX, centerY - 35);

                    // Draw one continuous wave that stretches toward the sail
                    const amp = 12;
                    const baseWavelengthPx = 22;
                    const shiftedWavelengthPx = baseWavelengthPx * (1 + speedFactor * 1.6);
                    const phase = timeDop * 40;
                    const dx = 2;

                    const shiftedHue = 220 - (speedFactor * 220);
                    const waveGrad = ctxDop.createLinearGradient(sourceX, 0, sailX, 0);
                    waveGrad.addColorStop(0, 'hsla(220, 100%, 60%, 0.9)');
                    waveGrad.addColorStop(1, `hsla(${shiftedHue}, 100%, 60%, 0.9)`);
                    ctxDop.strokeStyle = waveGrad;
                    ctxDop.lineWidth = 2;

                    let phaseAccum = -phase;
                    ctxDop.beginPath();
                    for (let x = sourceX; x <= sailX; x += dx) {
                        const distFactor = (x - sourceX) / (sailX - sourceX);
                        const localWavelength = baseWavelengthPx + (shiftedWavelengthPx - baseWavelengthPx) * distFactor;
                        phaseAccum += dx * (2 * Math.PI / localWavelength);
                        const y = centerY + Math.sin(phaseAccum) * amp;
                        if (x === sourceX) ctxDop.moveTo(x, y);
                        else ctxDop.lineTo(x, y);
                    }
                    ctxDop.stroke();
                    
                    animFrame7 = requestAnimationFrame(drawDop);
                };
                drawDop();
            }

            // --- 2. Beam Capture Animation ---
            const canvasCap = document.getElementById('tutorial-anim-capture');
            if (canvasCap) {
                const ctxCap = canvasCap.getContext('2d');
                let timeCap = 0;
                const drawCap = () => {
                    const dpr = window.devicePixelRatio || 1;
                    const rect = canvasCap.getBoundingClientRect();
                    canvasCap.width = rect.width * dpr; canvasCap.height = rect.height * dpr;
                    const w = canvasCap.width / dpr; const h = canvasCap.height / dpr;
                    ctxCap.resetTransform(); ctxCap.scale(dpr, dpr); ctxCap.clearRect(0, 0, w, h);
                    ctxCap.textAlign = 'center';
                    
                    timeCap += 0.02;
                    const cx = w / 2;
                    const cy = h / 2;
                    
                    // Sail Size (Fixed)
                    const rSail = 40;
                    
                    // Beam Size (Oscillating)
                    // t goes 0 -> 1 -> 0
                    const t = (Math.sin(timeCap) + 1) / 2; 
                    // Beam radius from 0.5 * rSail (Good) to 2.5 * rSail (Bad)
                    const rBeam = rSail * (0.5 + t * 2.0);
                    
                    const ratio = rBeam / rSail;
                    const fHit = ratio <= 1 ? 1.0 : (rSail*rSail)/(rBeam*rBeam); // Simple flat-top approx for viz
                    
                    // 1. Draw "Wasted" Beam (Outer)
                    if (rBeam > rSail) {
                        ctxCap.beginPath();
                        ctxCap.arc(cx, cy, rBeam, 0, Math.PI * 2);
                        ctxCap.fillStyle = 'rgba(50, 100, 255, 0.2)'; // Faint blue
                        ctxCap.fill();
                        ctxCap.strokeStyle = 'rgba(50, 100, 255, 0.4)';
                        ctxCap.stroke();
                        
                        // Label Wasted
                        ctxCap.fillStyle = '#6688ff';
                        ctxCap.textAlign = 'center'; ctxCap.font = '10px monospace';
                        ctxCap.fillText("WASTED POWER", cx, cy - rBeam - 5);
                    }
                    
                    // 2. Draw "Captured" Beam (Intersection with Sail)
                    // Since beam is centered, this is just the smaller of the two circles
                    const rCaptured = Math.min(rSail, rBeam);
                    ctxCap.beginPath();
                    ctxCap.arc(cx, cy, rCaptured, 0, Math.PI * 2);
                    ctxCap.fillStyle = 'rgba(100, 255, 150, 0.6)'; // Bright green
                    ctxCap.fill();
                    
                    // 3. Draw Sail Outline
                    ctxCap.beginPath();
                    ctxCap.arc(cx, cy, rSail, 0, Math.PI * 2);
                    ctxCap.strokeStyle = '#ffffff';
                    ctxCap.lineWidth = 2;
                    ctxCap.stroke();
                    ctxCap.fillStyle = '#fff';
                    ctxCap.fillText("SAIL", cx, cy + rSail + 15);

                    // 4. Metrics
                    const barW = 140;
                    const barH = 6;
                    const barX = w / 2 - barW / 2;
                    const barY = h - 25;
                    
                    // Background
                    ctxCap.fillStyle = '#333';
                    ctxCap.fillRect(barX, barY, barW, barH);
                    
                    // Fill
                    ctxCap.fillStyle = fHit > 0.9 ? '#00ffcc' : '#ffaa00';
                    ctxCap.fillRect(barX, barY, barW * fHit, barH);
                    
                    ctxCap.fillStyle = '#ccc';
                    ctxCap.fillText(`CAPTURE: ${(fHit*100).toFixed(0)}%`, cx, barY - 8);
                    
                    animFrame8 = requestAnimationFrame(drawCap);
                };
                drawCap();
            }

            // --- 3. Aerodynamics Animation ---
            const canvasAero = document.getElementById('tutorial-anim-aero');
            if (canvasAero) {
                const ctxAero = canvasAero.getContext('2d');
                let timeAero = 0;
                const drawAero = () => {
                    const dpr = window.devicePixelRatio || 1;
                    const rect = canvasAero.getBoundingClientRect();
                    canvasAero.width = rect.width * dpr; canvasAero.height = rect.height * dpr;
                    const w = canvasAero.width / dpr; const h = canvasAero.height / dpr;
                    ctxAero.resetTransform(); ctxAero.scale(dpr, dpr); ctxAero.clearRect(0, 0, w, h);
                    
                    timeAero += 0.015;
                    const cx = w / 2;
                    const cy = h / 2;
                    
                    // Mach cycle 0.5 to 3.0
                    const cycle = (Math.sin(timeAero) + 1) / 2; 
                    const mach = 0.5 + cycle * 2.5;
                    
                    // Draw Sail (Side view wedge)
                    ctxAero.beginPath();
                    ctxAero.moveTo(cx, cy - 20);
                    ctxAero.lineTo(cx - 15, cy + 20);
                    ctxAero.lineTo(cx + 15, cy + 20);
                    ctxAero.closePath();
                    ctxAero.fillStyle = '#ccc';
                    ctxAero.fill();
                    
                    // Heat Glow (Stagnation)
                    if (mach > 0.8) {
                        const heatAlpha = Math.min(1, (mach - 0.8) * 0.6);
                        ctxAero.globalCompositeOperation = 'lighter';
                        ctxAero.beginPath();
                        ctxAero.arc(cx, cy - 20, 15, 0, Math.PI*2);
                        const grad = ctxAero.createRadialGradient(cx, cy-20, 2, cx, cy-20, 15);
                        grad.addColorStop(0, `rgba(255, 100, 50, ${heatAlpha})`);
                        grad.addColorStop(1, 'rgba(255, 50, 0, 0)');
                        ctxAero.fillStyle = grad;
                        ctxAero.fill();
                        ctxAero.globalCompositeOperation = 'source-over';
                    }

                    // Shockwave Lines (Mach Cone)
                    if (mach >= 1.0) {
                        const mu = Math.asin(1 / mach); // Mach angle
                        const coneLen = 100;
                        const dx = Math.tan(mu) * coneLen;
                        
                        ctxAero.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                        ctxAero.lineWidth = 2;
                        ctxAero.beginPath();
                        ctxAero.moveTo(cx, cy - 20);
                        ctxAero.lineTo(cx - dx, cy - 20 + coneLen);
                        ctxAero.moveTo(cx, cy - 20);
                        ctxAero.lineTo(cx + dx, cy - 20 + coneLen);
                        ctxAero.stroke();
                        
                        ctxAero.fillStyle = '#ffaa00';
                        ctxAero.font = '10px monospace';
                        ctxAero.textAlign = 'center';
                        ctxAero.fillText("SHOCKWAVE", cx - dx - 25, cy + 20);
                    }

                    // Particles (Streamlines)
                    ctxAero.fillStyle = 'rgba(100, 200, 255, 0.5)';
                    const particleCount = 30;
                    for(let i=0; i<particleCount; i++) {
                        // Fixed positions relative to screen, flowing DOWN
                        let py = (timeAero * 200 + i * (h/particleCount)) % (h + 50) - 25;
                        let px = (i % 6) * 15 + (cx - 45) + (i%2)*7;
                        
                        // Deflection logic
                        const dy = py - (cy - 20);
                        const dist = Math.sqrt((px - cx)**2 + dy*dy);
                        
                        if (dy < 0 && Math.abs(px - cx) < 20) {
                            // Approaching sail
                            // If Subsonic, curve early. If Supersonic, go straight until shock.
                            if (mach < 1.0) {
                                // Smooth curve
                                const repulsion = 1000 / (dist + 1);
                                if (px < cx) px -= repulsion; else px += repulsion;
                            } else {
                                // Sudden deflection
                                const mu = Math.asin(1 / mach);
                                const shockY = (Math.abs(px - cx) / Math.tan(mu));
                                if (Math.abs(dy) < shockY + 10) { // Inside shock
                                    if (px < cx) px -= 15; else px += 15;
                                }
                            }
                        }
                        
                        ctxAero.beginPath();
                        ctxAero.arc(px, py, 1.5, 0, Math.PI*2);
                        ctxAero.fill();
                    }
                    
                    // Label
                    ctxAero.fillStyle = '#fff';
                    ctxAero.textAlign = 'left';
                    ctxAero.font = '12px monospace';
                    ctxAero.fillText(`MACH: ${mach.toFixed(2)}`, 10, 20);
                    
                    animFrame9 = requestAnimationFrame(drawAero);
                };
                drawAero();
            }

            // --- 4. Pointing Animation ---
            const canvasPoint = document.getElementById('tutorial-anim-pointing');
            if (canvasPoint) {
                const ctxPoint = canvasPoint.getContext('2d');
                let timePoint = 0;
                const drawPoint = () => {
                    const dpr = window.devicePixelRatio || 1;
                    const rect = canvasPoint.getBoundingClientRect();
                    canvasPoint.width = rect.width * dpr; canvasPoint.height = rect.height * dpr;
                    const w = canvasPoint.width / dpr; const h = canvasPoint.height / dpr;
                    ctxPoint.resetTransform(); ctxPoint.scale(dpr, dpr); ctxPoint.clearRect(0, 0, w, h);
                    
                    timePoint += 0.01;
                    
                    // Source on left
                    const sourceX = 30;
                    const sourceY = h / 2;
                    
                    // Target oscillates distance
                    const distT = (Math.sin(timePoint) + 1) / 2; // 0 to 1
                    const targetX = 100 + distT * (w - 140);
                    
                    // Jitter Angle (High frequency noise)
                    const jitterMag = 0.08; // radians
                    const noise = (Math.random() - 0.5) * jitterMag;
                    
                    // Draw Source
                    ctxPoint.fillStyle = '#444';
                    ctxPoint.fillRect(sourceX - 10, sourceY - 10, 20, 20);
                    
                    // Draw Target (Size scales 1/dist to simulate perspective, though 2D)
                    const size = 12 * (1 - distT * 0.6);
                    ctxPoint.fillStyle = '#eee';
                    ctxPoint.beginPath();
                    ctxPoint.arc(targetX, sourceY, size, 0, Math.PI*2);
                    ctxPoint.fill();
                    
                    // Beam
                    const endY = sourceY + Math.tan(noise) * (targetX - sourceX);
                    
                    ctxPoint.strokeStyle = '#00ffcc';
                    ctxPoint.lineWidth = 1;
                    ctxPoint.beginPath();
                    ctxPoint.moveTo(sourceX, sourceY);
                    ctxPoint.lineTo(targetX, endY);
                    ctxPoint.stroke();
                    
                    // Hit Check
                    const hit = Math.abs(endY - sourceY) < size;
                    
                    // Status Text
                    ctxPoint.textAlign = 'center';
                    ctxPoint.font = 'bold 12px monospace';
                    if (hit) {
                        ctxPoint.fillStyle = '#00ffcc';
                        ctxPoint.fillText("LOCKED", w/2, 20);
                    } else {
                        ctxPoint.fillStyle = '#ff3333';
                        ctxPoint.fillText("MISS", w/2, 20);
                    }
                    
                    // Range Text
                    ctxPoint.fillStyle = '#aaa';
                    ctxPoint.font = '10px monospace';
                    ctxPoint.fillText(distT < 0.3 ? "CLOSE RANGE" : "LONG RANGE", w/2, h - 10);
                    
                    animFrame10 = requestAnimationFrame(drawPoint);
                };
                drawPoint();
            }

            // --- 5. Orbit Animation ---
            const canvasOrb = document.getElementById('tutorial-anim-orbit');
            if (canvasOrb) {
                const ctxOrb = canvasOrb.getContext('2d');
                let timeOrb = 0;
                const drawOrb = () => {
                    const dpr = window.devicePixelRatio || 1;
                    const rect = canvasOrb.getBoundingClientRect();
                    canvasOrb.width = rect.width * dpr; canvasOrb.height = rect.height * dpr;
                    const w = canvasOrb.width / dpr; const h = canvasOrb.height / dpr;
                    ctxOrb.resetTransform(); ctxOrb.scale(dpr, dpr); ctxOrb.clearRect(0, 0, w, h);
                    
                    timeOrb += 0.015;
                    const cycle = (timeOrb % 4) / 4; 
                    
                    const cx = 50; // Earth X
                    const cy = h / 2;
                    const rEarth = 30;
                    
                    // 1. Draw Earth
                    ctxOrb.fillStyle = '#1a3a66';
                    ctxOrb.beginPath(); ctxOrb.arc(cx, cy, rEarth, 0, Math.PI*2); ctxOrb.fill();
                    ctxOrb.strokeStyle = '#4488ff'; ctxOrb.lineWidth = 2; ctxOrb.stroke();
                    
                    // 2. Calculate Positions
                    // Break point is at cycle = 0.6
                    const isEscaped = cycle > 0.6;
                    
                    // Sail Position
                    let sailX;
                    if (!isEscaped) {
                        // Struggling: Move slow
                        sailX = cx + rEarth + 20 + (cycle / 0.6) * 80;
                    } else {
                        // Freedom: Surge forward
                        const escapeT = (cycle - 0.6) / 0.4;
                        sailX = cx + rEarth + 100 + escapeT * (w - cx - rEarth - 120);
                    }
                    
                    // 3. Draw Gravity Tether
                    if (!isEscaped) {
                        const tetherAlpha = 1.0 - (cycle / 0.6) * 0.7;
                        ctxOrb.beginPath();
                        ctxOrb.strokeStyle = `rgba(180, 100, 255, ${tetherAlpha})`;
                        ctxOrb.lineWidth = 3 * (1 - cycle/0.6) + 1;
                        
                        // Vibrating line
                        ctxOrb.moveTo(cx + rEarth, cy);
                        const segments = 10;
                        for(let i=1; i<=segments; i++) {
                            const tx = (cx + rEarth) + (i/segments) * (sailX - cx - rEarth - 10);
                            const ty = cy + Math.sin(timeOrb * 30 + i) * (cycle / 0.6) * 5;
                            ctxOrb.lineTo(tx, ty);
                        }
                        ctxOrb.stroke();
                        
                        ctxOrb.fillStyle = `rgba(180, 100, 255, ${tetherAlpha})`;
                        ctxOrb.font = '10px monospace';
                        ctxOrb.textAlign = 'center';
                        ctxOrb.fillText("GRAVITY PULL", (cx + sailX)/2, cy - 15);
                    } else if (cycle < 0.75) {
                        // No shatter effect (removed per request)
                    }
                    
                    // 4. Draw Sail
                    ctxOrb.fillStyle = isEscaped ? '#00ffcc' : '#eee';
                    ctxOrb.shadowBlur = isEscaped ? 15 : 0;
                    ctxOrb.shadowColor = '#00ffcc';
                    ctxOrb.fillRect(sailX - 10, cy - 15, 4, 30); // Edge on view
                    ctxOrb.shadowBlur = 0;
                    
                    // 5. Status Text
                    ctxOrb.font = 'bold 14px monospace';
                    ctxOrb.textAlign = 'center';
                    if (isEscaped) {
                        ctxOrb.fillStyle = '#00ffcc';
                        ctxOrb.fillText("ESCAPE VELOCITY REACHED!", w/2, 30);
                        ctxOrb.font = '10px monospace';
                        ctxOrb.fillText("ENERGY () > 0", w/2, 45);
                    } else {
                        ctxOrb.fillStyle = '#ff4444';
                        ctxOrb.fillText("BOUND BY GRAVITY", w/2, 30);
                        ctxOrb.font = '10px monospace';
                        ctxOrb.fillText("ENERGY () < 0", w/2, 45);
                    }
                    
                    animFrame12 = requestAnimationFrame(drawOrb);
                };
                drawOrb();
            }
        } else if (learnMoreKey === "mission") {
            tutorialInfoContent.innerHTML = `
                    <h2>Mission Presets & Escape Toggle</h2>
                    <p>The mission buttons load curated physics presets (altitude, wavelength, aperture, power, mass, coupling, and beam model). They are not just visuals: they reconfigure the laser, sail, and environment to match the mission profile.</p>

                    <h3 style="color:#fff; margin-top:30px;">XERIONYX (Atmospheric, 48 km)</h3>
                    <p><strong>Objective:</strong> Launch ultra-light (1-gram) probes to Earth escape velocity (&gt;11.2 km/s) using inexpensive hardware.</p>
                    <p><strong>Core idea:</strong> Trade precision optics for raw power. Instead of billion-dollar phased arrays, XERIONYX uses incoherent industrial blue lasers and <strong>ablative propulsion</strong> (vaporizing a coating to create thrust).</p>
                    <p><strong>Launchpad:</strong> A high-altitude balloon lifts the 2 m sail to ~48 km, bypassing most of the atmosphere's drag and optical distortion.</p>
                    <p><strong>Laser engine:</strong> Roughly 10,000 mass-produced blue diode lasers (NUBM44 class) are fiber-coupled into a ~70 kW beam.</p>
                    <p><strong>Optics:</strong> A segmented 4 m mirror array (7 parabolic dishes on a stabilized barge) shapes the beam into a tight ~0.01 mrad divergence column.</p>
                    <p><strong>Flight profile:</strong> The beam hits a carbon-doped plastic coating, ablates material, and produces thrust that is ~1000x stronger than pure radiation pressure. The sail accelerates at ~25 g and reaches escape speed in 20 minutes.</p>
                    <p><strong>Bottom line:</strong> A reusable light-powered launcher that costs very little per shot, enabling fleets of micro-probes.</p>

                    <h3 style="color:#fff; margin-top:30px;">STARSHOT (Interstellar, 60,000 km)</h3>
                    <p><strong>Objective:</strong> Send gram-scale probes toward nearby stars using an ultra-powerful, highly coherent phased-array laser.</p>
                    <p><strong>Core idea:</strong> Use a huge, coherent laser array (kilometer-scale effective aperture) to keep the beam tightly focused over vast distances, pushing a reflective dielectric sail.</p>
                    <p><strong>Assumptions:</strong> Very high power (hundreds of GW), near-diffraction-limited beam quality, and a highly reflective sail to minimize heating.</p>
                    <p><strong>In the sim:</strong> STARSHOT enables diffraction-limited beam spread, radiation-pressure coupling, and a much larger launch distance, illustrating the coherent-optics pathway versus XERIONYX's ablative approach.</p>

                    <h3 style="color:#fff; margin-top:30px;">Escape Toggle</h3>
                    <p><strong>Stop sim at Earth escape:</strong> When ON, the simulation stops once the specific orbital energy becomes positive (escape). When OFF, the sim continues to show what happens beyond escape velocity.</p>
                `;
        } else if (learnMoreKey === "main_controls") {
            tutorialInfoContent.innerHTML = `
                    <h2>Main Controls Reference</h2>
                    <p>These controls allow you to manually tune the physical parameters of the laser source, the sailcraft, and the simulation environment.</p>

                    <h3 style="color:#fff; margin-top:30px;">Preset Defaults (Editable via Laser/Sail)</h3>
                    <p>These values load from the mission preset, but you can override them in the Laser and Sail panels.</p>
                    <table style="width:100%; border-collapse:collapse; font-size:12px; margin-top:8px;">
                        <thead>
                            <tr>
                                <th style="text-align:left; padding:6px; border-bottom:1px solid #333; color:#ccc;">Property</th>
                                <th style="text-align:left; padding:6px; border-bottom:1px solid #333; color:#ccc;">XERIONYX (Ablative)</th>
                                <th style="text-align:left; padding:6px; border-bottom:1px solid #333; color:#ccc;">STARSHOT (Dielectric)</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td style="padding:6px; border-bottom:1px solid #222;">Emissivity ()</td>
                                <td style="padding:6px; border-bottom:1px solid #222; font-family:monospace;">0.92</td>
                                <td style="padding:6px; border-bottom:1px solid #222; font-family:monospace;">0.01</td>
                            </tr>
                            <tr>
                                <td style="padding:6px; border-bottom:1px solid #222;">Absorptance model</td>
                                <td style="padding:6px; border-bottom:1px solid #222;">Derived from reflectance</td>
                                <td style="padding:6px; border-bottom:1px solid #222; font-family:monospace;">Fixed 1e-8</td>
                            </tr>
                            <tr>
                                <td style="padding:6px; border-bottom:1px solid #222;">Atmospheric transmission (zenith)</td>
                                <td style="padding:6px; border-bottom:1px solid #222; font-family:monospace;">0.6</td>
                                <td style="padding:6px; border-bottom:1px solid #222; font-family:monospace;">0.7</td>
                            </tr>
                            <tr>
                                <td style="padding:6px; border-bottom:1px solid #222;">Beam model default</td>
                                <td style="padding:6px; border-bottom:1px solid #222;">Incoherent / geometric</td>
                                <td style="padding:6px; border-bottom:1px solid #222;">Diffraction-limited</td>
                            </tr>
                            <tr>
                                <td style="padding:6px; border-bottom:1px solid #222;">Coupling model default</td>
                                <td style="padding:6px; border-bottom:1px solid #222;">Manual Cm</td>
                                <td style="padding:6px; border-bottom:1px solid #222;">Radiation pressure (auto)</td>
                            </tr>
                            <tr>
                                <td style="padding:6px; border-bottom:1px solid #222;">Destruction temp limit (K)</td>
                                <td style="padding:6px; border-bottom:1px solid #222; font-family:monospace;">5000</td>
                                <td style="padding:6px; border-bottom:1px solid #222; font-family:monospace;">625</td>
                            </tr>
                            <tr>
                                <td style="padding:6px; border-bottom:1px solid #222;">Max irradiance limit</td>
                                <td style="padding:6px; border-bottom:1px solid #222; font-family:monospace;">8.0e9 W/m</td>
                                <td style="padding:6px; border-bottom:1px solid #222;">Auto from temp limit</td>
                            </tr>
                            <tr>
                                <td style="padding:6px;">Beam quality (Strehl)</td>
                                <td style="padding:6px; font-family:monospace;">0.85</td>
                                <td style="padding:6px; font-family:monospace;">0.85</td>
                            </tr>
                            <tr>
                                <td style="padding:6px;">Spot size floor (W_FLOOR)</td>
                                <td style="padding:6px; font-family:monospace;">1e-4 m</td>
                                <td style="padding:6px; font-family:monospace;">1e-4 m</td>
                            </tr>
                        </tbody>
                    </table>

                    <h3 style="color:#fff; margin-top:30px;">Laser Parameters</h3>
                    <p><strong>Power (MW):</strong> The total optical power output from the laser source. Higher power increases thrust but also raises the sail's temperature.</p>
                    <p><strong>Aperture Diameter (m):</strong> The diameter of the final transmitting lens or mirror. A larger aperture creates a tighter focus over longer distances due to reduced diffraction.</p>
                    
                    <div class="tutorial-info-animation">
                        <canvas id="tutorial-anim-aperture" style="width:100%; height:100%;"></canvas>
                    </div>

                    <h3 style="color:#fff; margin-top:30px;">Diffraction Physics: Wavelength & Beam Spread</h3>
                    <p><strong>Wavelength (nm):</strong> The "color" of the laser light. This fundamental property dictates how much the beam spreads out over distance (Diffraction).</p>
                    <p>Shorter wavelengths (like <strong>Blue 450nm</strong>) can be focused into a much tighter cone than longer wavelengths (like <strong>Infrared 1064nm</strong>). A tighter beam means more energy hits the sail at long range.</p>
                    
                    <div class="tutorial-info-animation">
                        <canvas id="tutorial-anim-wavelength-cone" style="width:100%; height:100%;"></canvas>
                    </div>

                    <h3 style="color:#fff; margin-top:30px;">Material Physics: Reflectance & Sail Type</h3>
                    <p>The sail's material determines how it interacts with the laser. We simulate two distinct classes of propulsion:</p>
                    <ul>
                        <li><strong>Dielectric (Starshot):</strong> Highly reflective (>99.9%). It bounces photons to get momentum (2x thrust of absorption) and stays cool because it absorbs almost nothing.</li>
                        <li><strong>Ablative (Xerionyx):</strong> Highly absorptive. It absorbs the laser energy, heats up, and vaporizes a surface layer. The jet of hot gas provides massive thrust (100x-1000x more than reflection).</li>
                    </ul>

                    <p><strong>Reflectance (0-1):</strong> The fraction of light reflected. <br>
                    <strong>Absorptance:</strong> The rest is absorbed (or transmitted), turning into heat and ablation.</p>

                    <div class="tutorial-info-animation">
                        <canvas id="tutorial-anim-reflectance" style="width:100%; height:100%;"></canvas>
                    </div>

                    <h3 style="color:#fff; margin-top:30px;">Ablative Sail Parameters</h3>
                    <p><strong>Coupling Cm (N/MW):</strong> The "Thrust Coupling Coefficient." It defines how many Newtons of force are produced per Megawatt of laser power.</p>
                    
                    <div class="tutorial-info-animation">
                        <canvas id="tutorial-anim-ablation" style="width:100%; height:100%;"></canvas>
                    </div>

                    <p>For <strong>Ablation</strong>, the laser vaporizes a thin layer of material, which jets away at high speed. This "rocket effect" is typically 10-100x stronger than pure radiation pressure (where light simply bounces off).</p>
                    
                    <h3 style="color:#fff; margin-top:30px;">Simulation & Mass</h3>
                    <p><strong>Time Speed (x):</strong> Multiplies the rate at which time passes in the simulation. High speeds are useful for long-duration coasting.</p>
                    <p><strong>Total Mass (kg):</strong> The combined mass of the sail material and the payload. Mass directly determines acceleration for a given thrust (F=ma).</p>
                `;
        } else {
            tutorialInfoContent.innerHTML = `
                <h2>Wavefront & Coherence</h2>
                <p>A laser's effectiveness depends heavily on its <strong>coherence</strong>how well-synchronized the light waves are as they travel.</p>
                
                <div class="tutorial-info-animation">
                    <canvas id="tutorial-anim-canvas" style="width:100%; height:100%;"></canvas>
                </div>

                <p><strong>Phased Array (Coherent):</strong> In this mode, all light sources are "phase-locked," meaning their peaks and troughs line up perfectly. This allows the beam to stay tightly focused over massive distances (diffraction-limited).</p>
                <p><strong>Incoherent Source:</strong> Here, the sources emit light with random phases. The waves don't sync, causing the beam to spread much faster geometrically.</p>
                
                <h3 style="color:#fff; margin-top:30px;">Aperture Synthesis</h3>
                <p>A key benefit of a phased array is that multiple small lasers can work together to behave as <strong>one giant laser</strong>.</p>

                <div class="tutorial-info-animation">
                    <canvas id="tutorial-anim-canvas-2" style="width:100%; height:100%;"></canvas>
                </div>

                <p>Normally, a small laser has a wide beam spread due to <strong>diffraction</strong>. However, when multiple emitters are perfectly phase-locked, they create a "synthetic aperture" equal to the size of the whole array.</p>
                <p>This allows the beam to stay tightly focused over thousands of kilometers, whereas an incoherent array of the same size would simply scatter light like a floodlight.</p>

                <h3 style="color:#fff; margin-top:30px;">Constructive Interference</h3>
                <p>When waves are perfectly phase-locked, they undergo <strong>Constructive Interference</strong>. Their peaks stack on top of each other, creating a "super-wave."</p>

                <div class="tutorial-info-animation">
                    <canvas id="tutorial-anim-canvas-3" style="width:100%; height:100%;"></canvas>
                </div>

                <p>Because the intensity of light is proportional to the <strong>square</strong> of its amplitude, this stacking effect means that a phased array delivers significantly more power to a small spot than an incoherent source of the same total wattage.</p>

                <h3 style="color:#fff; margin-top:30px;">Electronic Beam Steering</h3>
                <p>Phased arrays can "steer" their beam without moving a single mechanical part. By slightly delaying the phase of each emitter in sequence, the common wavefront is tilted.</p>

                <div id="steering-animation-container" class="tutorial-info-animation" style="width: 100%; aspect-ratio: 1 / 1; height: auto; margin: 24px 0;">
                    <canvas id="tutorial-anim-canvas-4" style="width:100%; height:100%;"></canvas>
                </div>

                <p>This allows for near-instantaneous tracking of fast-moving objects, like our laser sail, across the sky. An incoherent system would require massive, slow mechanical mirrors to achieve the same result.</p>
            `;
        }

        tutorialInfoBox.classList.add('active');
        tutorialInfoBox.setAttribute('aria-hidden', 'false');

        if (learnMoreKey === "wavefront") {
            
            // Animation 1: Coherence
            const canvas = document.getElementById('tutorial-anim-canvas');
            if (canvas) {
                const ctx = canvas.getContext('2d');
                let time = 0;
                const draw = () => {
                    const dpr = window.devicePixelRatio || 1;
                    const rect = canvas.getBoundingClientRect();
                    canvas.width = rect.width * dpr; canvas.height = rect.height * dpr;
                    const w = canvas.width / dpr; const h = canvas.height / dpr;
                    ctx.resetTransform(); ctx.scale(dpr, dpr); ctx.clearRect(0, 0, w, h);
                    const midX = w / 2; const emitters = 5; const spacing = h / (emitters + 1); time += 0.15;
                    ctx.font = 'bold 10px monospace'; ctx.fillStyle = '#aaa'; ctx.textAlign = 'center';
                    ctx.fillText("COHERENT (PHASED)", w * 0.25, 20); ctx.fillText("INCOHERENT", w * 0.75, 20);
                    for (let i = 0; i < emitters; i++) {
                        const y = spacing * (i + 1);
                        
                        // Phased Side (Left) - 1064nm Red
                        ctx.beginPath();
                        ctx.strokeStyle = '#ff3333';
                        ctx.lineWidth = 1.5;
                        ctx.globalAlpha = 0.6;
                        for (let x = 10; x < midX - 20; x += 2) {
                            const wave = Math.sin((x * 0.1) - time) * 8;
                            if (x === 10) ctx.moveTo(x, y + wave); else ctx.lineTo(x, y + wave);
                        }
                        ctx.stroke();

                        // Incoherent Side (Right) - 450nm Blue
                        ctx.beginPath();
                        ctx.strokeStyle = '#3366ff';
                        ctx.globalAlpha = 0.6;
                        const phaseOffset = (i * 1.5);
                        for (let x = midX + 20; x < w - 10; x += 2) {
                            const wave = Math.sin((x * 0.1) - time + phaseOffset) * 8;
                            if (x === midX + 20) ctx.moveTo(x, y + wave); else ctx.lineTo(x, y + wave);
                        }
                        ctx.stroke();
                    }
                    ctx.setLineDash([4, 4]); ctx.globalAlpha = 0.8; ctx.strokeStyle = '#fff';
                    const frontX1 = 40 + (time * 10) % (midX - 80);
                    ctx.beginPath(); ctx.moveTo(frontX1, spacing - 15); ctx.lineTo(frontX1, h - spacing + 15); ctx.stroke();
                    ctx.beginPath();
                    for (let i = 0; i < emitters; i++) {
                        const y = spacing * (i + 1); const phaseOffset = (i * 1.5);
                        const frontX2 = (midX + 50) + ((time * 10) % (w - midX - 100)) - (Math.sin(phaseOffset) * 10);
                        if (i === 0) ctx.moveTo(frontX2, y); else ctx.lineTo(frontX2, y);
                    }
                    ctx.stroke(); ctx.setLineDash([]);
                    animFrame = requestAnimationFrame(draw);
                };
                draw();
            }

            // Animation 2: Aperture Synthesis
            const canvas2 = document.getElementById('tutorial-anim-canvas-2');
            if (canvas2) {
                const ctx2 = canvas2.getContext('2d');
                let time2 = 0;
                const draw2 = () => {
                    const dpr = window.devicePixelRatio || 1;
                    const rect = canvas2.getBoundingClientRect();
                    canvas2.width = rect.width * dpr; canvas2.height = rect.height * dpr;
                    const w = canvas2.width / dpr; const h = canvas2.height / dpr;
                    ctx2.resetTransform(); ctx2.scale(dpr, dpr); ctx2.clearRect(0, 0, w, h);
                    time2 += 0.02;
                    const midX = w / 2;
                    ctx2.font = 'bold 10px monospace'; ctx2.fillStyle = '#aaa'; ctx2.textAlign = 'center';
                    ctx2.fillText("SYNTHETIC APERTURE (PHASED)", w * 0.25, 20);
                    ctx2.fillText("SMALL APERTURES (INCOHERENT)", w * 0.75, 20);
                    const emitters = 5;
                    const spacing = (h - 60) / (emitters + 1);
                    ctx2.fillStyle = '#ff3333';
                    for(let i=0; i<emitters; i++) {
                        const y = 40 + spacing * (i+1);
                        ctx2.fillRect(20, y-2, 4, 4);
                    }
                    const grad2 = ctx2.createLinearGradient(24, h/2, midX-20, h/2);
                    grad2.addColorStop(0, 'rgba(255, 51, 51, 0.5)');
                    grad2.addColorStop(1, 'rgba(255, 51, 51, 0.1)');
                    ctx2.fillStyle = grad2;
                    ctx2.beginPath();
                    ctx2.moveTo(24, 40 + spacing);
                    ctx2.lineTo(24, 40 + spacing * emitters);
                    ctx2.lineTo(midX-30, h/2 + 15);
                    ctx2.lineTo(midX-30, h/2 - 15);
                    ctx2.closePath();
                    ctx2.fill();
                    for(let i=0; i<emitters; i++) {
                        const y = 40 + spacing * (i+1);
                        ctx2.fillStyle = '#3366ff';
                        ctx2.fillRect(midX + 20, y-2, 4, 4);
                        const grad = ctx2.createLinearGradient(midX + 24, y, w - 20, y);
                        grad.addColorStop(0, 'rgba(51, 102, 255, 0.4)');
                        grad.addColorStop(1, 'rgba(51, 102, 255, 0)');
                        ctx2.fillStyle = grad;
                        ctx2.beginPath();
                        ctx2.moveTo(midX + 24, y);
                        ctx2.lineTo(w - 30, y - 25);
                        ctx2.lineTo(w - 30, y + 25);
                        ctx2.fill();
                    }
                    animFrame2 = requestAnimationFrame(draw2);
                };
                draw2();
            }

            // Animation 3: Constructive Interference
            const canvas3 = document.getElementById('tutorial-anim-canvas-3');
            if (canvas3) {
                const ctx3 = canvas3.getContext('2d');
                let time3 = 0;
                const draw3 = () => {
                    const dpr = window.devicePixelRatio || 1;
                    const rect = canvas3.getBoundingClientRect();
                    canvas3.width = rect.width * dpr; canvas3.height = rect.height * dpr;
                    const w = canvas3.width / dpr; const h = canvas3.height / dpr;
                    ctx3.resetTransform(); ctx3.scale(dpr, dpr); ctx3.clearRect(0, 0, w, h);
                    time3 += 0.1;
                    const centerY = h / 2;
                    // Two input waves
                    ctx3.lineWidth = 2;
                    ctx3.globalAlpha = 0.4;
                    ctx3.strokeStyle = '#ff3333';
                    ctx3.beginPath();
                    for(let x=0; x<w; x+=2) {
                        const y = centerY - 40 + Math.sin(x*0.05 - time3) * 15;
                        if(x===0) ctx3.moveTo(x,y); else ctx3.lineTo(x,y);
                    }
                    ctx3.stroke();
                    
                    ctx3.strokeStyle = '#ff3333';
                    ctx3.beginPath();
                    for(let x=0; x<w; x+=2) {
                        const y = centerY - 40 + Math.sin(x*0.05 - time3) * 15;
                        if(x===0) ctx3.moveTo(x,y); else ctx3.lineTo(x,y);
                    }
                    ctx3.stroke();

                    // Resultant wave (Constructive)
                    ctx3.globalAlpha = 1.0;
                    ctx3.lineWidth = 3;
                    ctx3.strokeStyle = '#fff';
                    ctx3.shadowBlur = 10;
                    ctx3.shadowColor = '#ff3333';
                    ctx3.beginPath();
                    for(let x=0; x<w; x+=2) {
                        const y = centerY + 40 + (Math.sin(x*0.05 - time3) * 30);
                        if(x===0) ctx3.moveTo(x,y); else ctx3.lineTo(x,y);
                    }
                    ctx3.stroke();
                    ctx3.shadowBlur = 0;
                    ctx3.font = '10px monospace'; ctx3.fillStyle = '#aaa'; ctx3.textAlign = 'center';
                    ctx3.fillText("INDIVIDUAL EMITTERS", w/2, centerY - 65);
                    ctx3.fillText("COMBINED (SUMMED) WAVE", w/2, centerY + 85);
                    animFrame3 = requestAnimationFrame(draw3);
                };
                draw3();
            }

            // Animation 4: Beam Steering (Focused Intensity & Ripples)
            animFrame4 = null;
            const canvas4 = document.getElementById('tutorial-anim-canvas-4');
            if (canvas4) {
                const ctx4 = canvas4.getContext('2d');
                let time4 = 0;
                const draw4 = () => {
                    const dpr = window.devicePixelRatio || 1;
                    const rect = canvas4.getBoundingClientRect();
                    canvas4.width = rect.width * dpr; canvas4.height = rect.height * dpr;
                    const w = canvas4.width / dpr; const h = canvas4.height / dpr;
                    ctx4.resetTransform(); ctx4.scale(dpr, dpr); ctx4.clearRect(0, 0, w, h);
                    
                    time4 += 0.5;
                    const emitterX = 30;
                    const plotBaselineX = w - 70;
                    const mainAreaWidth = plotBaselineX - emitterX;
                    const emittersCount = 13; // Increased for better resolution
                    const arrayPadding = 30;
                    const arraySpacing = (h - arrayPadding * 2) / (emittersCount - 1);
                    
                    const steerAngle = Math.sin(time4 * 0.03) * 0.5;
                    const peakY = h/2 + Math.tan(steerAngle) * mainAreaWidth;

                    // 1. RIPPLE PATH PREPARATION
                    const ripplePath = new Path2D();
                    for (let i = 0; i < emittersCount; i++) {
                        const ey = arrayPadding + i * arraySpacing;
                        const phaseShift = -(i - (emittersCount-1)/2) * Math.sin(steerAngle) * 22;
                        for (let r = 0; r < mainAreaWidth + 50; r += 60) {
                            const radius = (time4 * 2 + r + phaseShift) % (mainAreaWidth + 100);
                            if (radius > 0) {
                                ripplePath.moveTo(emitterX + radius, ey);
                                ripplePath.arc(emitterX, ey, radius, -Math.PI/2.2, Math.PI/2.2);
                            }
                        }
                    }

                    // 2. DRAW INTENSE FOCUSED BEAM
                    ctx4.save();
                    // First, draw the ripples with a left-to-right intensity gradient
                    const intensityGrad = ctx4.createLinearGradient(emitterX, 0, plotBaselineX, 0);
                    intensityGrad.addColorStop(0, 'rgba(255, 51, 51, 0.05)'); // Very dim at emitters
                    intensityGrad.addColorStop(1, 'rgba(255, 51, 51, 0.9)');  // Bright at focus point
                    
                    ctx4.strokeStyle = intensityGrad;
                    ctx4.lineWidth = 2.0;
                    ctx4.stroke(ripplePath);

                    // Apply a soft conic mask to create the focus cone shape
                    ctx4.globalCompositeOperation = 'destination-in';
                    const conicMask = ctx4.createConicGradient(steerAngle, plotBaselineX, peakY);
                    conicMask.addColorStop(0.4, 'rgba(0, 0, 0, 0)');
                    conicMask.addColorStop(0.5, 'rgba(0, 0, 0, 1)');
                    conicMask.addColorStop(0.6, 'rgba(0, 0, 0, 0)');
                    
                    ctx4.fillStyle = conicMask;
                    ctx4.fillRect(0, 0, w, h);
                    ctx4.restore();

                    // 3. DRAW AMBIENT RIPPLES (Low Opacity)
                    ctx4.strokeStyle = '#ff3333';
                    ctx4.lineWidth = 1.0;
                    ctx4.globalAlpha = 0.08;
                    ctx4.stroke(ripplePath);

                    // 4. DRAW UI ELEMENTS (Emitters & Plot)
                    ctx4.globalAlpha = 1.0;
                    for (let i = 0; i < emittersCount; i++) {
                        const ey = arrayPadding + i * arraySpacing;
                        ctx4.fillStyle = '#ff3333';
                        ctx4.fillRect(emitterX - 10, ey - 2, 6, 4);
                    }

                    // Intensity Plot
                    ctx4.strokeStyle = 'rgba(255,255,255,0.1)';
                    ctx4.beginPath();
                    ctx4.moveTo(plotBaselineX, 30);
                    ctx4.lineTo(plotBaselineX, h - 30);
                    ctx4.stroke();

                    ctx4.beginPath();
                    ctx4.strokeStyle = '#fff';
                    ctx4.lineWidth = 2;
                    for(let y=30; y<h-30; y+=1) {
                        const dist = (y - peakY) * 0.15;
                        let intensity = (Math.abs(dist) < 0.001) ? 1 : Math.pow(Math.sin(dist) / dist, 2);
                        const px = plotBaselineX + (intensity * 50);
                        if(y===30) ctx4.moveTo(px, y); else ctx4.lineTo(px, y);
                    }
                    ctx4.stroke();
                    
                    ctx4.fillStyle = '#aaa';
                    ctx4.font = '9px monospace';
                    ctx4.textAlign = 'left';
                    ctx4.fillText("INTENSITY", plotBaselineX - 5, 25);

                    ctx4.textAlign = 'center';
                    ctx4.font = 'bold 10px monospace';
                    ctx4.fillText("ELECTRONIC STEERING", w * 0.5, 15);
                    
                    animFrame4 = requestAnimationFrame(draw4);
                };
                draw4();
            }
        } else if (learnMoreKey === "main_controls") {
                // Animation: Wavelength Cone
                const canvasWl = document.getElementById('tutorial-anim-wavelength-cone');
                if (canvasWl) {
                    const ctxWl = canvasWl.getContext('2d');
                    let timeWl = 0;
                    const drawWl = () => {
                        const dpr = window.devicePixelRatio || 1;
                        const rect = canvasWl.getBoundingClientRect();
                        canvasWl.width = rect.width * dpr; canvasWl.height = rect.height * dpr;
                        const w = canvasWl.width / dpr; const h = canvasWl.height / dpr;
                        ctxWl.resetTransform(); ctxWl.scale(dpr, dpr); ctxWl.clearRect(0, 0, w, h);
                        
                        timeWl += 0.015;
                        // Cycle wavelength: 400nm -> 1064nm -> 400nm
                        const t = (Math.sin(timeWl) + 1) / 2; 
                        const wlVal = 400 + t * 664; // nm
                        
                        // Physics-ish mapping: Angle ~ Lambda
                        const minAngle = 0.02; // radians
                        const maxAngle = 0.12; 
                        const coneAngle = minAngle + t * (maxAngle - minAngle);
                        
                        const srcX = 40;
                        const srcY = h / 2;
                        const len = w - 80;
                        
                        // Calculate visual RGB
                        const rgb = wavelengthToRgb(wlVal * 1e-9);
                        const color = `rgb(${rgb.r},${rgb.g},${rgb.b})`;
                        
                        // Draw Source
                        ctxWl.fillStyle = '#222';
                        ctxWl.fillRect(srcX - 20, srcY - 15, 20, 30);
                        ctxWl.fillStyle = color;
                        ctxWl.fillRect(srcX - 5, srcY - 5, 5, 10);
                        
                        // Draw Cone
                        const ySpread = Math.tan(coneAngle) * len;
                        
                        const grad = ctxWl.createLinearGradient(srcX, 0, srcX + len, 0);
                        grad.addColorStop(0, `rgba(${rgb.r},${rgb.g},${rgb.b},0.9)`);
                        grad.addColorStop(1, `rgba(${rgb.r},${rgb.g},${rgb.b},0.1)`);
                        
                        ctxWl.fillStyle = grad;
                        ctxWl.beginPath();
                        ctxWl.moveTo(srcX, srcY);
                        ctxWl.lineTo(srcX + len, srcY - ySpread);
                        ctxWl.lineTo(srcX + len, srcY + ySpread);
                        ctxWl.closePath();
                        ctxWl.fill();
                        
                        // Draw Waves inside cone
                        ctxWl.strokeStyle = 'rgba(255,255,255,0.3)';
                        ctxWl.lineWidth = 1;
                        ctxWl.beginPath();
                        const waveCount = 8;
                        const freq = 0.2 + (1-t)*0.3; // Higher freq for blue
                        const speed = timeWl * 5;
                        
                        for(let i=0; i<3; i++) { // 3 rays
                             const angle = -coneAngle*0.6 + i * (coneAngle*0.6);
                             const rayLen = len;
                             const ex = srcX + Math.cos(angle)*rayLen;
                             const ey = srcY + Math.sin(angle)*rayLen;
                             
                             // Just draw simple sine along the ray
                             for(let step=0; step<rayLen; step+=4) {
                                 const dx = step;
                                 const dy = Math.sin(dx * freq - speed) * 3;
                                 // Rotate
                                 const px = srcX + dx * Math.cos(angle) - dy * Math.sin(angle);
                                 const py = srcY + dx * Math.sin(angle) + dy * Math.cos(angle);
                                 if(step===0) ctxWl.moveTo(px,py); else ctxWl.lineTo(px,py);
                             }
                        }
                        ctxWl.stroke();
                        
                        // Text Info
                        ctxWl.fillStyle = '#fff';
                        ctxWl.font = 'bold 14px monospace';
                        ctxWl.textAlign = 'right';
                        ctxWl.fillText(`${Math.round(wlVal)} nm`, w - 20, 30);
                        
                        ctxWl.font = '11px monospace';
                        ctxWl.fillStyle = '#aaa';
                        ctxWl.fillText(t < 0.3 ? "LOW DIFFRACTION" : "HIGH DIFFRACTION", w - 20, 45);

                        animFrame11 = requestAnimationFrame(drawWl);
                    };
                    drawWl();
                }

                // Animation: Reflectance & Sail Type
                const canvasRef = document.getElementById('tutorial-anim-reflectance');
                if (canvasRef) {
                    const ctxRef = canvasRef.getContext('2d');
                    let timeRef = 0;
                    let particles = [];
                    
                    const drawRef = () => {
                        const dpr = window.devicePixelRatio || 1;
                        const rect = canvasRef.getBoundingClientRect();
                        canvasRef.width = rect.width * dpr; canvasRef.height = rect.height * dpr;
                        const w = canvasRef.width / dpr; const h = canvasRef.height / dpr;
                        ctxRef.resetTransform(); ctxRef.scale(dpr, dpr); ctxRef.clearRect(0, 0, w, h);
                        
                        timeRef += 0.01;
                        
                        // Cycle State: 0-4s Dielectric, 4-8s Ablative
                        const cycleLen = 6;
                        const tCycle = timeRef % cycleLen;
                        const isDielectric = tCycle < (cycleLen / 2);
                        
                        // Transition Factor (0 to 1)
                        let factor = 0; 
                        if (isDielectric) factor = Math.min(1, tCycle * 2); 
                        else factor = Math.min(1, (tCycle - cycleLen/2) * 2);
                        
                        const sailX = w / 2;
                        const sailY = h / 2;
                        const sailH = 60;
                        const sailW = 6;
                        
                        // Params
                        // Dielectric: R=0.95, A=0.01
                        // Ablative: R=0.1, A=0.9
                        const R = isDielectric ? 0.95 : 0.1;
                        const A = isDielectric ? 0.01 : 0.9;
                        const T_trans = 1 - R - A; // Transmittance
                        
                        // 1. Draw Waves Incoming (Left -> Sail)
                        const waveSpacing = 15;
                        const waveSpeed = 2;
                        const offset = (timeRef * 40) % waveSpacing;
                        
                        ctxRef.lineWidth = 2;
                        ctxRef.strokeStyle = isDielectric ? '#aaffaa' : '#aaaaff'; // Greenish vs Blueish source? Keep simple
                        ctxRef.strokeStyle = '#ffffff';
                        
                        ctxRef.beginPath();
                        for(let x = 20; x < sailX - 5; x += waveSpacing) {
                            const waveX = x + offset;
                            if (waveX < sailX - 5) {
                                // Draw vertical wave front
                                ctxRef.moveTo(waveX, sailY - 25);
                                ctxRef.lineTo(waveX, sailY + 25);
                            }
                        }
                        ctxRef.stroke();
                        
                        // 2. Draw Reflected (Sail -> Left)
                        if (R > 0.2) {
                            ctxRef.strokeStyle = 'rgba(100, 255, 100, 0.8)'; // Green reflection
                            ctxRef.beginPath();
                            for(let x = sailX - 5; x > 20; x -= waveSpacing) {
                                const waveX = x - offset;
                                if (waveX > 20 && waveX < sailX - 5) {
                                    ctxRef.moveTo(waveX, sailY - 25);
                                    ctxRef.lineTo(waveX, sailY + 25);
                                }
                            }
                            ctxRef.stroke();
                        }
                        
                        // 3. Draw Transmitted (Sail -> Right)
                        if (T_trans > 0.2) { // Not really used in these two models but good for completeness
                            ctxRef.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                            ctxRef.beginPath();
                            for(let x = sailX + 10; x < w - 20; x += waveSpacing) {
                                const waveX = x + offset;
                                if (waveX > sailX + 10 && waveX < w - 20) {
                                    ctxRef.moveTo(waveX, sailY - 25);
                                    ctxRef.lineTo(waveX, sailY + 25);
                                }
                            }
                            ctxRef.stroke();
                        }
                        
                        // 4. Draw Sail
                        ctxRef.fillStyle = isDielectric ? '#ccffee' : '#222';
                        ctxRef.strokeStyle = isDielectric ? '#fff' : '#444';
                        ctxRef.lineWidth = 2;
                        ctxRef.fillRect(sailX - sailW/2, sailY - sailH/2, sailW, sailH);
                        ctxRef.strokeRect(sailX - sailW/2, sailY - sailH/2, sailW, sailH);
                        
                        // 5. Effects (Heating/Ablation)
                        if (!isDielectric) {
                            // Ablative Mode
                            // Glow
                            const glow = Math.sin(timeRef * 10) * 0.2 + 0.8;
                            ctxRef.shadowBlur = 15;
                            ctxRef.shadowColor = `rgba(255, 100, 0, ${glow})`;
                            ctxRef.fillStyle = `rgba(255, 50, 0, ${glow * 0.5})`;
                            ctxRef.fillRect(sailX - sailW/2, sailY - sailH/2, sailW, sailH);
                            ctxRef.shadowBlur = 0;
                            
                            // Particles (Jetting Left? No, Thrust is forward, so jet is BACK towards source? 
                            // Wait, Light pushes Sail RIGHT. 
                            // Ablation jet goes LEFT (towards light).
                            // Reaction force pushes Sail RIGHT.
                            // So particles go LEFT.
                            
                            if (Math.random() > 0.3) {
                                particles.push({
                                    x: sailX - 4,
                                    y: sailY + (Math.random() - 0.5) * 40,
                                    vx: -2 - Math.random() * 3,
                                    vy: (Math.random() - 0.5) * 2,
                                    life: 1.0
                                });
                            }
                        } else {
                            particles = []; // Clear in dielectric mode
                        }
                        
                        // Update Particles
                        for(let i=particles.length-1; i>=0; i--) {
                            const p = particles[i];
                            p.x += p.vx;
                            p.y += p.vy;
                            p.life -= 0.05;
                            if (p.life <= 0) particles.splice(i, 1);
                            else {
                                ctxRef.fillStyle = `rgba(255, 150, 50, ${p.life})`;
                                ctxRef.fillRect(p.x, p.y, 2, 2);
                            }
                        }
                        
                        // 6. UI / Info
                        const barW = 100;
                        const barH = 8;
                        const barX = w / 2 - barW / 2;
                        const barY = h - 30;
                        
                        // Label
                        ctxRef.font = 'bold 12px monospace';
                        ctxRef.textAlign = 'center';
                        if (isDielectric) {
                            ctxRef.fillStyle = '#00ffcc';
                            ctxRef.fillText("TYPE: DIELECTRIC (STARSHOT)", w/2, 20);
                            ctxRef.fillStyle = '#aaffaa';
                            ctxRef.font = '10px monospace';
                            ctxRef.fillText("PHOTONS REFLECTED (2x MOMENTUM)", w/2, 35);
                        } else {
                            ctxRef.fillStyle = '#ffaa44';
                            ctxRef.fillText("TYPE: ABLATIVE (XERIONYX)", w/2, 20);
                            ctxRef.fillStyle = '#ffccaa';
                            ctxRef.font = '10px monospace';
                            ctxRef.fillText("ABSORBED -> VAPORIZATION -> THRUST", w/2, 35);
                        }

                        // Reflectivity Bar
                        ctxRef.fillStyle = '#333';
                        ctxRef.fillRect(barX, barY, barW, barH);
                        ctxRef.fillStyle = '#fff';
                        ctxRef.fillRect(barX, barY, barW * R, barH);
                        ctxRef.fillStyle = '#aaa';
                        ctxRef.font = '10px monospace';
                        ctxRef.textAlign = 'center';
                        ctxRef.fillText(`REFLECTANCE: ${(R*100).toFixed(0)}%`, w/2, barY - 5);

                        animFrame7 = requestAnimationFrame(drawRef);
                    };
                    drawRef();
                }

                // Animation: Aperture
                const canvasAp = document.getElementById('tutorial-anim-aperture');
                if (canvasAp) {
                    const ctxAp = canvasAp.getContext('2d');
                    let timeAp = 0;
                    const drawAp = () => {
                        const dpr = window.devicePixelRatio || 1;
                        const rect = canvasAp.getBoundingClientRect();
                        canvasAp.width = rect.width * dpr; canvasAp.height = rect.height * dpr;
                        const w = canvasAp.width / dpr; const h = canvasAp.height / dpr;
                        ctxAp.resetTransform(); ctxAp.scale(dpr, dpr); ctxAp.clearRect(0, 0, w, h);
                        
                        timeAp += 0.02;
                        const t = (Math.sin(timeAp) * 0.5 + 0.5); // Normalized 0 to 1
                        
                        // Synchronized linear mapping: 
                        // Small aperture (t=0) -> Large divergence
                        // Large aperture (t=1) -> Small divergence
                        const apertureSize = 6 + t * 22;  // Source: 6 to 28
                        const targetRadius = 85 - t * 55; // Target: 85 to 30
                        
                        const centerX = 60;
                        const centerY = h / 2;
                        const targetX = w - 60;
                        
                        // Draw Beam
                        const rgb = wavelengthToRgb(LAMBDA);
                        const grad = ctxAp.createLinearGradient(centerX, 0, targetX, 0);
                        const startAlpha = 0.65;
                        const endAlpha = 0.12 + (t * 0.5);
                        grad.addColorStop(0, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${startAlpha.toFixed(3)})`);
                        grad.addColorStop(1, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${endAlpha.toFixed(3)})`);
                        
                        ctxAp.fillStyle = grad;
                        ctxAp.beginPath();
                        ctxAp.moveTo(centerX, centerY - apertureSize);
                        ctxAp.lineTo(targetX, centerY - targetRadius);
                        ctxAp.lineTo(targetX, centerY + targetRadius);
                        ctxAp.lineTo(centerX, centerY + apertureSize);
                        ctxAp.closePath();
                        ctxAp.fill();

                        // Draw Aperture Plates
                        ctxAp.strokeStyle = '#fff';
                        ctxAp.lineWidth = 3;
                        ctxAp.beginPath();
                        ctxAp.moveTo(centerX, 10); ctxAp.lineTo(centerX, centerY - apertureSize);
                        ctxAp.moveTo(centerX, h - 10); ctxAp.lineTo(centerX, centerY + apertureSize);
                        ctxAp.stroke();
                        
                        // Labels
                        ctxAp.fillStyle = '#aaa';
                        ctxAp.font = '10px monospace';
                        ctxAp.textAlign = 'left';
                        ctxAp.fillText("APERTURE", centerX + 15, h - 15);
                        ctxAp.textAlign = 'right';
                        ctxAp.fillText("DIVERGENCE", targetX, h - 15);

                        animFrame5 = requestAnimationFrame(drawAp);
                    };
                    drawAp();
                }

                // Animation: Ablation
                const canvasAb = document.getElementById('tutorial-anim-ablation');
                if (canvasAb) {
                    const ctxAb = canvasAb.getContext('2d');
                    let timeAb = 0;
                    const particles = [];
                    const drawAb = () => {
                        const dpr = window.devicePixelRatio || 1;
                        const rect = canvasAb.getBoundingClientRect();
                        canvasAb.width = rect.width * dpr; canvasAb.height = rect.height * dpr;
                        const w = canvasAb.width / dpr; const h = canvasAb.height / dpr;
                        ctxAb.resetTransform(); ctxAb.scale(dpr, dpr); ctxAb.clearRect(0, 0, w, h);
                        
                        timeAb += 0.05;
                        const centerY = h / 2;
                        const splitX = w * 0.5; // Perfect center split
                        const rgb = wavelengthToRgb(LAMBDA);
                        const laserColor = `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;
                        
                        // Separate timing for independent speeds
                        const tLeft = (timeAb * 0.04) % 1.0;  // Slow movement
                        const tRight = (timeAb * 0.22) % 1.0; // Fast movement
                        
                        // 1. RADIATION PRESSURE (Left)
                        const leftMargin = 30;
                        const leftRange = splitX - leftMargin - 40;
                        const radX = leftMargin + tLeft * leftRange; 
                        
                        // Light incoming from left edge
                        ctxAb.strokeStyle = laserColor; ctxAb.lineWidth = 3;
                        ctxAb.beginPath(); ctxAb.moveTo(10, centerY); ctxAb.lineTo(radX, centerY); ctxAb.stroke();
                        
                        // Sail (Reflective)
                        ctxAb.fillStyle = '#eee';
                        ctxAb.fillRect(radX, centerY - 20, 3, 40);
                        
                        const leftCenter = splitX * 0.5;
                        ctxAb.fillStyle = '#aaa'; ctxAb.font = '9px monospace'; ctxAb.textAlign = 'center';
                        ctxAb.fillText("RADIATION (LIGHT)", leftCenter, 20);
                        ctxAb.fillText("SMALL PUSH", leftCenter, h - 15);

                        // Divider
                        ctxAb.strokeStyle = '#333'; ctxAb.beginPath(); ctxAb.moveTo(splitX, 10); ctxAb.lineTo(splitX, h-10); ctxAb.stroke();

                        // 2. ABLATION (Right)
                        const rightStart = splitX + 30;
                        const rightRange = (w - 30) - rightStart - 10;
                        const ablX = rightStart + tRight * rightRange;
                        
                        // Light (High Power Blue)
                        ctxAb.strokeStyle = laserColor; ctxAb.lineWidth = 3;
                        ctxAb.beginPath(); ctxAb.moveTo(splitX + 10, centerY); ctxAb.lineTo(ablX, centerY); ctxAb.stroke();
                        
                        // Sail (Absorptive/Black)
                        ctxAb.fillStyle = '#222';
                        ctxAb.strokeStyle = '#444'; ctxAb.lineWidth = 1;
                        ctxAb.fillRect(ablX, centerY - 20, 5, 40);
                        ctxAb.strokeRect(ablX, centerY - 20, 5, 40);
                        
                        // Reset particles on loop reset to prevent phantom trails (using tRight)
                        if (tRight < 0.05) particles.length = 0;
                        
                        // Particles (Ejecta) jetting BACKWARDS (towards the split)
                        if (Math.random() > 0.2) {
                            particles.push({x: ablX, y: centerY - 20 + Math.random()*40, vx: -4 - Math.random()*5, vy: (Math.random()-0.5)*3, life: 1});
                        }
                        for (let i = particles.length - 1; i >= 0; i--) {
                            const p = particles[i];
                            p.x += p.vx; p.y += p.vy; p.life -= 0.04;
                            if (p.life <= 0 || p.x < splitX + 5) particles.splice(i, 1);
                            else {
                                ctxAb.globalAlpha = p.life;
                                ctxAb.fillStyle = '#ffaa44';
                                ctxAb.fillRect(p.x, p.y, 2, 2);
                            }
                        }
                        ctxAb.globalAlpha = 1.0;
                        const rightCenter = splitX + (w - splitX) * 0.5;
                        ctxAb.fillStyle = '#aaa'; ctxAb.fillText("ABLATION (MASS)", rightCenter, 20);
                        ctxAb.fillText("LARGE JET THRUST", rightCenter, h - 15);

                        animFrame6 = requestAnimationFrame(drawAb);
                    };
                    drawAb();
                }
        }
    };

    tutorialLearnMore.addEventListener('click', () => {
        const step = tutorialSteps[currentStepIndex];
        const learnMoreKey = step && step.learnMore ? step.learnMore : null;
        if (!learnMoreKey) return;
        openTutorialInfo(learnMoreKey);
    });

    if (telemetryInfoBtn) {
        telemetryInfoBtn.addEventListener('click', () => {
            openTutorialInfo("telemetry");
        });
    }
    if (wavefrontInfoBtn) {
        wavefrontInfoBtn.addEventListener('click', () => {
            openTutorialInfo("wavefront");
        });
    }
    if (mainControlInfoBtn) {
        mainControlInfoBtn.addEventListener('click', () => {
            openTutorialInfo("main_controls");
        });
    }

    if (tutorialInfoClose) {
        tutorialInfoClose.addEventListener('click', () => {
            closeTutorialInfoBox();
        });
    }

    document.addEventListener('click', (event) => {
        if (!tutorialInfoBox || !tutorialInfoBox.classList.contains('active')) return;
        if (event.target.closest('#tutorial-info-box')) return;
        if (event.target.closest('.info-btn') || event.target.closest('#tutorial-learn-more')) return;
        closeTutorialInfoBox();
    });

    if (tutorialOverlay) {
        tutorialOverlay.addEventListener('click', (event) => {
            if (event.target === tutorialOverlay) {
                closeTutorialInfoBox();
            }
        });
    }
}

tutorialSkip.addEventListener('click', endTutorial);

// --- Wavefront Animation Logic ---
let resizeWaveCanvas = null;
(function() {
    const waveCanvas = document.getElementById('wave-canvas');
    if (!waveCanvas) return;
    const waveCtx = waveCanvas.getContext('2d');
    const sourceTypeEl = document.getElementById('wave-source-type');
    const coherenceEl = document.getElementById('wave-coherence');
    const lambdaSourceEl = document.getElementById('wave-lambda-source');
    const lambdaSailEl = document.getElementById('wave-lambda-sail');
    const waveBarEl = document.getElementById('wavefront-bar');
    const waveMarkerEl = document.getElementById('wave-lambda-marker');
    
    let time = 0;
    
    resizeWaveCanvas = function() {
        const isMobile = document.body.classList.contains('is-mobile');
        const rect = waveCanvas.getBoundingClientRect();
        let w = rect.width;
        let h = rect.height;
        if (w < 10) w = waveCanvas.offsetWidth || 300;
        if (h < 10) h = waveCanvas.offsetHeight || 150;
        
        if (isMobile) {
            h = Math.max(h, 180);
        }

        waveCanvas.width = w * window.devicePixelRatio;
        waveCanvas.height = h * window.devicePixelRatio;
        waveCtx.scale(window.devicePixelRatio, window.devicePixelRatio);
    }
    window.addEventListener('resize', resizeWaveCanvas);
    resizeWaveCanvas();

    function draw() {
        const width = waveCanvas.width / window.devicePixelRatio;
        const height = waveCanvas.height / window.devicePixelRatio;
        
        waveCtx.clearRect(0, 0, width, height);
        
        // Use global simulation state
        const isPhased = useDiffractionBeam; 
        const rgb = wavelengthToRgb(LAMBDA);
        const colorStr = `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;
        
        if (sourceTypeEl) sourceTypeEl.textContent = isPhased ? "PHASED ARRAY" : "INCOHERENT SOURCE";
        if (coherenceEl) {
            coherenceEl.textContent = isPhased ? "PHASE LOCKED" : "RANDOM PHASE";
            // Fixed white color
            coherenceEl.style.color = '#ffffff';
        }
        const lambdaSource = LAMBDA;
        const lambdaObserved = LAMBDA * dopplerFactor(v / C);
        if (lambdaSourceEl) lambdaSourceEl.textContent = `${Math.round(lambdaSource * 1e9)} nm`;
        if (lambdaSailEl) lambdaSailEl.textContent = `${Math.round(lambdaObserved * 1e9)} nm`;
        if (waveBarEl) {
            const srcRgb = wavelengthToRgb(lambdaSource);
            const sailRgb = wavelengthToRgb(lambdaObserved);
            waveBarEl.style.setProperty('--wave-src-color', `rgb(${srcRgb.r}, ${srcRgb.g}, ${srcRgb.b})`);
            waveBarEl.style.setProperty('--wave-sail-color', `rgb(${sailRgb.r}, ${sailRgb.g}, ${sailRgb.b})`);
        }
        if (waveMarkerEl) {
            const ratio = lambdaObserved / Math.max(lambdaSource, 1e-12);
            const normalized = Math.max(-1, Math.min(1, (ratio - 1) / 0.4));
            const pos = 0.5 + 0.45 * normalized;
            waveMarkerEl.style.left = `${(pos * 100).toFixed(2)}%`;
        }

        const showWaves = laserOn;

        const emitters = 7;
        const spacing = height / (emitters + 1);
        
        // Adjust frequency based on wavelength relative to 450nm baseline
        const baseLambda = 450e-9;
        const baseFreq = 0.15;
        const speed = 0.2;

        const lambdaStart = LAMBDA;
        const beta = Math.max(-0.6, Math.min(0.6, v / C));
        const doppler = dopplerFactor(beta);
        const exaggeration = 3;
        const lambdaEnd = LAMBDA * (1 + (doppler - 1) * exaggeration);
        const rgbStart = wavelengthToRgb(lambdaStart);
        const rgbEnd = wavelengthToRgb(lambdaEnd);
        const waveGrad = waveCtx.createLinearGradient(24, 0, width, 0);
        waveGrad.addColorStop(0, `rgba(${rgbStart.r}, ${rgbStart.g}, ${rgbStart.b}, 0.7)`);
        waveGrad.addColorStop(1, `rgba(${rgbEnd.r}, ${rgbEnd.g}, ${rgbEnd.b}, 0.7)`);

        if (showWaves) {
            time += 1;
        }

        waveCtx.lineWidth = 2;
        
        for (let i = 0; i < emitters; i++) {
            const yBase = spacing * (i + 1);
            
            // Draw Emitter Box
            waveCtx.fillStyle = '#222';
            waveCtx.fillRect(10, yBase - 5, 10, 10);
            
            // Draw Emitter Light (LED)
            waveCtx.fillStyle = colorStr;
            waveCtx.fillRect(18, yBase - 2, 4, 4);
            
            if (!showWaves) {
                continue;
            }

            waveCtx.beginPath();
            waveCtx.strokeStyle = waveGrad;
            waveCtx.globalAlpha = 0.5;
            
            // Phase Logic
            // If phased, all offsets are 0 (or constant relative to each other).
            // If incoherent, use the fixed random-like offset.
            const phaseOffset = isPhased ? 0 : ((i * 137.5) % 360) * (Math.PI / 180);
            const step = 4;
            let phase = -(time * speed) + phaseOffset;
            
            for (let x = 24; x < width; x += step) {
                const distFactor = (x - 24) / Math.max(1, width - 24);
                const localLambda = lambdaStart + (lambdaEnd - lambdaStart) * distFactor;
                const localFreq = baseFreq * (baseLambda / Math.max(localLambda, 1e-12));
                phase += localFreq * step;
                const waveY = Math.sin(phase) * 6;
                if (x === 24) waveCtx.moveTo(x, yBase + waveY);
                else waveCtx.lineTo(x, yBase + waveY);
            }
            waveCtx.stroke();
        }

        requestAnimationFrame(draw);
    }
    requestAnimationFrame(draw);
})();


// --- Mobile Telemetry Expand Logic ---
(function() {
    const expandBtn = document.getElementById('telemetry-expand-btn');
    const island = document.getElementById('telemetry-island');
    
    if (expandBtn && island) {
        expandBtn.addEventListener('click', function(e) {
            e.stopPropagation(); // Prevent bubbling if needed
            island.classList.toggle('expanded');
            const isExpanded = island.classList.contains('expanded');
            expandBtn.textContent = isExpanded ? '' : '+';
            expandBtn.setAttribute('aria-expanded', isExpanded);
        });
    }

    // Mobile Island Navigation Logic
    const navButtons = {
        'nav-plot': document.getElementById('plot-island'),
        'nav-wavefront': document.getElementById('wavefront-island'),
        'nav-coupling': document.getElementById('coupling-island'),
        'nav-extra': document.getElementById('extra-island')
    };

    const extraContent = document.getElementById('extra-island-content');
    const controlsLayout = document.querySelector('#controls-island .controls-layout');
    const laserPanel = controlsLayout ? controlsLayout.children[0] : null;
    const sailPanel = controlsLayout ? controlsLayout.children[2] : null;

    function openIsland(id) {
        const island = navButtons[id];
        if (!island) return;
        island.classList.remove('is-closing');

        if (id === 'nav-extra' && extraContent && laserPanel && sailPanel) {
            extraContent.appendChild(laserPanel);
            extraContent.appendChild(sailPanel);
            laserPanel.style.display = 'flex';
            sailPanel.style.display = 'flex';
        }

        island.classList.add('is-open');

        if (id === 'nav-plot' && typeof resizePlotCanvas === 'function') {
            // Sequence of calls to ensure it catches the layout as it animates/settles
            setTimeout(resizePlotCanvas, 50);
            setTimeout(resizePlotCanvas, 150);
            setTimeout(resizePlotCanvas, 400);
            setTimeout(drawPlot, 500);
        }

        if (id === 'nav-wavefront' && typeof resizeWaveCanvas === 'function') {
            setTimeout(resizeWaveCanvas, 50);
            setTimeout(resizeWaveCanvas, 200);
        }
    }

    function closeAllIslands() {
        const openIslands = Object.values(navButtons).filter(island => island && island.classList.contains('is-open'));
        const extraWasOpen = navButtons['nav-extra'] && navButtons['nav-extra'].classList.contains('is-open');

        openIslands.forEach(island => {
            island.classList.add('is-closing');
            island.classList.remove('is-open');
        });

        window.setTimeout(() => {
            openIslands.forEach(island => {
                island.classList.remove('is-closing');
            });

            if (extraWasOpen && extraContent && laserPanel && sailPanel && laserPanel.parentElement === extraContent) {
                if (controlsLayout) {
                    controlsLayout.insertBefore(laserPanel, controlsLayout.firstChild);
                    controlsLayout.appendChild(sailPanel);
                }
                laserPanel.style.display = '';
                sailPanel.style.display = '';
            }
        }, 360);
    }

    Object.keys(navButtons).forEach(id => {
        const btn = document.getElementById(id);
        if (btn) {
            btn.addEventListener('click', () => {
                closeAllIslands();
                openIsland(id);
            });
        }
    });

    document.querySelectorAll('.island-close-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            e.stopPropagation();
            closeAllIslands();
        });
    });

    // Close on overlay click (optional but good for UX)
    window.addEventListener('click', (e) => {
        if (e.target.classList.contains('mobile-overlay')) {
            closeAllIslands();
        }
    });
})();

</script>
</body>
</html>
